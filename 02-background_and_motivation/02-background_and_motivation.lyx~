#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass MPSthesis
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 0
\use_mathdots 0
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Overview of optimization methods 
\begin_inset CommandInset label
LatexCommand label
name "chap:02-Optimization_models"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% First paragraph has no indentation.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Optimization may be informally defined as the procedure of finding better
 solutions to a given problem that usually models some physical phenomenon.
 In our every day life, we are constantly solving small optimization problems,
 like choosing the shortest route to a friend's house, or organizing the
 appointments in our agenda.
 In general, these problems are small enough for us to find a good solution
 without extra help, but as they become larger and more complex, the aid
 of computers for their resolution is unavoidable.
\end_layout

\begin_layout Standard
Complex multidimensional optimization problems are popular in engineering,
 economics, physics and other scientific fields.
 When solving an optimization problem, the objective is to find a 
\begin_inset Quotes eld
\end_inset

good
\begin_inset Quotes erd
\end_inset

 solution in a 
\begin_inset Quotes eld
\end_inset

reasonable
\begin_inset Quotes erd
\end_inset

 computational time.
 In this respect, the field of mathematical optimization has received a
 lot of attention by the scientific community during the last decades.
 However, both 
\begin_inset Quotes eld
\end_inset

good
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

reasonable
\begin_inset Quotes erd
\end_inset

 are problem, application and context-specific concepts, in which the biggest
 challenge of selecting an appropiate optimization approach usually lays.
\end_layout

\begin_layout Standard
Mathematical optimization involves the process of finding solutions from
 a group of possible decisions, which may be defined as:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\min f(\vec{x})\qquad\vec{x}\in\Omega\subseteq\mathbb{R}^{n},
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\vec{x}=(x_{1},\dots,x_{n})$
\end_inset

 is a vector representing the decision variables, 
\begin_inset Formula $f(\vec{x})$
\end_inset

 is the objective function measuring the quality of the decisions and 
\begin_inset Formula $\Omega$
\end_inset

 is the set of feasible solutions of the problem, also known as search space.
 Note that the objective function 
\begin_inset Formula $f$
\end_inset

 makes it possible to define a total order relation between any pair of
 solutions in 
\begin_inset Formula $\Omega$
\end_inset

.
\end_layout

\begin_layout Standard
The search space 
\begin_inset Formula $\Omega$
\end_inset

 may also be expressed as a solution to a system of equalities or inequialities,
 e.g.:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
g(x_{1},\dots,x_{n}) & \leq & 0\nonumber \\
h(x_{1},\dots,x_{n}) & = & 0.
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Optimization problems involving the maximization of the objective function
 also fall into this category, since:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\max f(\vec{x})=-\min(-f(\vec{x})).\label{eq:02-maximization_minization_problem_relation}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
A point 
\begin_inset Formula $\vec{x}^{*}$
\end_inset

 is considered to be an unrestricted local minimum of a function 
\begin_inset Formula $f$
\end_inset

 if it holds a better value than all its neightbours, i.e., there exits 
\begin_inset Formula $\epsilon>0$
\end_inset

 so that:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
f(\vec{x}^{*})\le f(\vec{x})\qquad\forall\vec{x}\in\mathbb{R}^{n}\qquad\mid\vec{x}-\vec{x}^{*}\mid<\epsilon.\label{eq:02-local_minimum}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
Similarly, a point 
\begin_inset Formula $\vec{x}^{*}$
\end_inset

 is considered to be an unrestricted global minimum of a function 
\begin_inset Formula $f$
\end_inset

 if it holds a better value than all others, i.e.:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
f(\vec{x}^{*})\leq f(\vec{x})\qquad\forall\vec{x}\in\mathbb{R}^{n}.\label{eq:02-global_minimum}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The concepts of local and global minimum are considered strict if the inequaliti
es of Equations
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "eq:02-local_minimum"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "eq:02-global_minimum"

\end_inset

 are strict.
 Likewise, the definition of local and global maximum is given by the existing
 relation between a minimization and a maximization problem, as specified
 in Equation
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "eq:02-maximization_minization_problem_relation"

\end_inset

, i.e., a point 
\begin_inset Formula $\vec{x}^{*}$
\end_inset

 is a local or global maximum of a function 
\begin_inset Formula $f$
\end_inset

 if and only if 
\begin_inset Formula $\vec{x}^{*}$
\end_inset

 is a local or global minimum of function 
\begin_inset Formula $-f$
\end_inset

, respectively.
\end_layout

\begin_layout Section
Gradient-based methods 
\begin_inset CommandInset label
LatexCommand label
name "sec:02-Gradient-based-methods"

\end_inset


\end_layout

\begin_layout Standard
Gradient-based methods are among the oldest and most studied optimization
 approaches.
 They are based on the derivative of the optimized function, using the first
 and even the second derivate of a function 
\begin_inset Formula $f$
\end_inset

.
 The name gradient follows from the derivative of multidimensional functions,
 
\begin_inset Formula $\nabla f(\vec{x})$
\end_inset

, which is simply a vector where each element is the slope of 
\begin_inset Formula $\vec{x}$
\end_inset

 in that dimension, i.e., 
\begin_inset Formula $<\frac{\partial f}{\partial x_{1}},\dots,\frac{\partial f}{\partial x_{n}}>$
\end_inset


\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Luke-Essentials_of_metaheuristics:2009"

\end_inset

.
\end_layout

\begin_layout Standard
The principle behind gradient-based methods is rather simple.
 Starting from an arbitrary value for 
\begin_inset Formula $x$
\end_inset

, a substraction (or addition) of a small positive value is iteratively
 applied to it, e.g., for gradient descent:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
x\leftarrow x-\alpha f'(x),
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\alpha$
\end_inset

 is a small positive value.
 Consequently, a positive slope will make 
\begin_inset Formula $x$
\end_inset

 decrease, whereas a negative slope will make it increase.
 Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:02-gradient_descent"

\end_inset

 shows an example of this behaviour.
 Therefore, 
\begin_inset Formula $x$
\end_inset

 will gradually move down the function until it finds its minimum, where
 
\begin_inset Formula $f'(x)$
\end_inset

 is zero, causing it to stop.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/gradient_descent.eps
	width 55text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Gradient descent with a negative slope, i.e.
 
\begin_inset Formula $x$
\end_inset

 is increasing.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:02-gradient_descent"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, gradient methods have certaing drawbacks that make them unsuitable
 for tackling a wide range of optimization problems.
 Take, for example, the time they take to converge.
 As gradient descent approaches a function minimum, it will skip this point
 and land on the other side.
 In the next step, something similar will happen, but this time from the
 other side of the minimum point, thus slowly approaching to the target
 in a 
\begin_inset Quotes eld
\end_inset

zig-zag
\begin_inset Quotes erd
\end_inset

 way.
 This behavior is directly related to the slope of the function at the given
 point, i.e., a steepest slope translates into a larger jump, and may be allivieat
ted by adjusting the value of 
\begin_inset Formula $\alpha$
\end_inset

.
 However, some functions (or regions of functions) may require smaller values,
 while for others a bigger value would be more appropiate.
 Newton's method improves this by taking the second derivative of the function
 into account, i.e.:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
x\leftarrow x-\alpha\frac{f'(x)}{f''(x)},
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
thus adjusting the value of 
\begin_inset Formula $\alpha$
\end_inset

 as it converges towards a point with zero slope 
\begin_inset CommandInset citation
LatexCommand cite
key "Luke-Essentials_of_metaheuristics:2009"

\end_inset

.
\end_layout

\begin_layout Standard
Another issue is how other points are handled.
 Beside maxima and minima points, some functions also contain saddle points
 (known as inflection points in one-dimensional functions).
 Clearly, the first derivative of a saddle point is zero, meaning gradient
 descent will stop looking for the minimum, even though it hasn't found
 it (see Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:02-gradient_descent_saddle_point"

\end_inset

).
 Newton's method, on the other hand, does not help either, even trying to
 divide by zero in this case.
 These observations clearly show how gradient methods get caught in local
 optima.
 Local optima of a function is defined as the optima (or minima in this
 case) of a local region.
 Similarly, global optima are defined as the optima of the whole domain
 of a function.
 It follows that gradient methods, as gradient descent or Newton’s method,
 are local optimization algorithms 
\begin_inset CommandInset citation
LatexCommand cite
key "Luke-Essentials_of_metaheuristics:2009"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/gradient_descent_saddle_point.eps
	width 55text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A saddle point or point of inflection, where the derivative is zero.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:02-gradient_descent_saddle_point"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
But maybe the biggest concern with gradient-based methods is they assume
 the function under optimization is derivable.
 This assumption holds only when optimizing a well-formed mathematical function.
 Unfortunately, this is generally not true, since in most cases the gradient
 is not computable because the function is not known.
 The only available approach in such situations is creating inputs to the
 function in order to assess their quality.
 Metaheuristics (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:02-Metaheuristics"

\end_inset

) are good candidates for this class of problems, for solving both moderate
 and large instances.
\end_layout

\begin_layout Section
Linear and non-linear programming
\end_layout

\begin_layout Standard
It was in the early 40s of the twentieth century, through the work of teams
 formed by mathematicians, economists and physicists, that the basis were
 established for the resolution of problems with a set of techniques known
 as linear and non-linear programming.
 Their initial goal was to solve different kinds of logistic problems during
 the second world war.
\end_layout

\begin_layout Standard
In a linear programming optimization problem, both the objective function
 
\begin_inset Formula $f$
\end_inset

 and a given set of constraints are linear functions.
 The constraints impose restrictions over 
\begin_inset Formula $\vec{x}$
\end_inset

, i.e., they must meet certain requirements as, for example, fullfil a limited
 availability of resources.
 A problem may be formulated as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\min f(\vec{x})=c\cdot\vec{x}\label{eq:02-linear_programming_objective_function}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
subject to
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
A\cdot\vec{x} & \le & b\label{eq:02-linear_programming_constraints}\\
\vec{x} & \ge & \vec{0}\nonumber 
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
\noindent
In the example above, the inequalities defined in 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:02-linear_programming_constraints"

\end_inset

 are the constraints to the linear program defined in 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:02-linear_programming_objective_function"

\end_inset

.
\end_layout

\begin_layout Standard
For solving continous, linear-optimization problems, efficient exact algorithms
 exist, such as the simplex method 
\begin_inset CommandInset citation
LatexCommand cite
key "Dantzig-Maximization_of_a_linear_function_of_variables_subject_to_linear_inequalities:1951"

\end_inset

 or the interior-points method 
\begin_inset CommandInset citation
LatexCommand cite
key "Karmarkar-A_new_polynomial_time_algorithm_for_linear_programming:1984"

\end_inset

.
 Indeed, linear programming is one of the most satisfactory models for solving
 optimization problems, since the feasible region of the problem is a convex
 set and the objective function is a convex function.
 It follows that the global optimum is a node of the polytope representing
 the feasible region 
\begin_inset CommandInset citation
LatexCommand cite
key "Talbi_Metaheuristics:2009"

\end_inset

.
 See Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:02-linear_programming_example"

\end_inset

 for a linear-programming example with several constraints.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/linear_programming.eps
	lyxscale 80
	width 55text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Graphical representation of a linear-programming example with two constraints,
 
\begin_inset Formula $c_{1}$
\end_inset

 and 
\begin_inset Formula $c_{2}$
\end_inset

.
 The greyed area is the polytope representing the region of feasible solutions.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:02-linear_programming_example"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Non-linear programming models, on the other hand, consider problems where
 the objective function 
\begin_inset Formula $f$
\end_inset

 and/or the constraints are non-linear 
\begin_inset CommandInset citation
LatexCommand cite
key "Bazaraa-Nonlinear_programming:2006"

\end_inset

.
 However, non-linear continuous problems are more difficult to solve.
 Despite several existing techniques to linearize such models, they often
 not only introduce extra variables and constraints, but also some degree
 of approximation 
\begin_inset CommandInset citation
LatexCommand cite
key "Glover-Improved_linear_programming_formulations_for_nonlinear_problems:1975"

\end_inset

.
 Moreover, some problem properties such as high dimensionality, parameter
 interaction, and multi-modality make these approaches ineffective.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Generally speaking, when dealing with real-world problems, the availability
 of analytical optimization models, such as those required by gradient methods
 or (non-)linear programming, is not guaranteed.
 Indeed, for some applications, only simulations or physical models are
 the available means for objective-function evaluation 
\begin_inset CommandInset citation
LatexCommand cite
key "Fu-Optimization_for_simulation:2002"

\end_inset

.
 Once again, metaheuristics appear as good candidates to solve different
 instance sizes of this class of problems.
 
\end_layout

\begin_layout Section
Metaheuristics 
\begin_inset CommandInset label
LatexCommand label
name "sec:02-Metaheuristics"

\end_inset


\end_layout

\begin_layout Standard
Metaheuristics, a term proposed by Glover in 
\begin_inset CommandInset citation
LatexCommand cite
key "Glover-Future_paths_for_integer_programming_and_links_to_artificial_intelligence:1986"

\end_inset

, represent a group of approximation algorithms designed to combine basic,
 heuristic principles with advanced high-level guidance methods, targeted
 at improving the efficiency of a search process.
 These techniques are meant to find good solutions to a given problem, for
 which the mathematical function is not available or its search space is
 big enough for an exhaustive search to be unfeasible 
\begin_inset CommandInset citation
LatexCommand cite
key "Kochenberger_Handbook_of_metaheuristics:2003"

\end_inset

.
\end_layout

\begin_layout Standard
From the theorical point of view, metaheuristics represent a subset of stochasti
c optimization, since they use some degree of randomness to find optimal
 (or as good as possible) solutions to hard problems.
 They are the most general of these kinds of algorithms, and are applied
 to a wide range of problems 
\begin_inset CommandInset citation
LatexCommand cite
key "Luke-Essentials_of_metaheuristics:2009"

\end_inset

.
 Unlike the exact optimization methods introduced in the previous sections,
 metaheuristics do not guarantee the optimality of the obtained solutions
 
\begin_inset CommandInset citation
LatexCommand cite
key "Talbi_Metaheuristics:2009"

\end_inset

.
 Moreover, they do not define how close the obtained solutions are from
 the optimal ones, as approximation algorithms do.
\end_layout

\begin_layout Standard
The characterization given by Blum and Roli 
\begin_inset CommandInset citation
LatexCommand cite
key "Blum-Metaheuristics_in_combinatorial_optimization_overview_and_coconceptual_comparison:2003"

\end_inset

 provides a clear overview of the fundamental properties associated with
 metaheuristics:
\end_layout

\begin_layout Itemize
metaheuristics are strategies that “guide” the search process;
\end_layout

\begin_layout Itemize
their goal is to efficiently explore the search space in order to find optimal
 or near-optimal solutions;
\end_layout

\begin_layout Itemize
they build upon techniques which range from simple local search procedures
 to complex learning processes;
\end_layout

\begin_layout Itemize
they are approximate and usually non-deterministic;
\end_layout

\begin_layout Itemize
they may incorporate mechanisms to avoid getting trapped in confined areas
 of the search space;
\end_layout

\begin_layout Itemize
their basic concepts permit an abstract-level description, which is not
 problem-specific;
\end_layout

\begin_layout Itemize
they may make use of domain-specific knowledge in the form of heuristics
 that are controlled by the upper level strategy;
\end_layout

\begin_layout Itemize
advanced metaheuristics use search experience (implemented as some form
 of memory) to guide the search process.
\end_layout

\begin_layout Standard
The strategies used by metaheuristics should provide a dynamic balance between
 the exploitation of the accumulated search experience (commonly called
 intensification) and the exploration of the search space (commonly called
 diversification) 
\begin_inset CommandInset citation
LatexCommand cite
key "Blum-Metaheuristics_in_combinatorial_optimization_overview_and_coconceptual_comparison:2003"

\end_inset

.
 This balance provides the necessary means to quickly identify promising
 regions, and early discarding those which have already been explored or
 don't provide solutions of better quality.
 Promising regions within the search space, which are identified by the
 obtained 
\begin_inset Quotes eld
\end_inset

good
\begin_inset Quotes erd
\end_inset

 solutions, are thoughfully explored during the intensification phase, hoping
 to find better solutions.
 On the other hand, during the diversification phase, not-yet-visited regions
 are explored, making sure the search space as a whole is evenly explored,
 thus avoid confining the search to a reduced number of regions.
 In this context, the ultimate search algorithm in terms of diversification
 is random search.
 Random search generates a random solution in the search space at each iteration
, without using memory 
\begin_inset CommandInset citation
LatexCommand cite
key "Talbi_Metaheuristics:2009"

\end_inset

.
 In terms of intensification, iterative local search is a representative
 algorithm.
 The steepest local search algorithm selects, at each iteration, the best
 neighboring solution that improves the current one 
\begin_inset CommandInset citation
LatexCommand cite
key "Talbi_Metaheuristics:2009"

\end_inset

.
\end_layout

\begin_layout Standard
Metaheuristics are applicable where state-of-the-art exact algorithms cannot
 tackle the given instances within the required time, either because of
 their size or structure.
 The meaning of 
\begin_inset Quotes eld
\end_inset

required time
\begin_inset Quotes erd
\end_inset

 within this context directly depends on the target optimization problem
 itself.
 A feasible or acceptable time may vary from some seconds to several months,
 again, depending on the target optimization problem, e.g., real-time decisions
 against structural-design problems.
\end_layout

\begin_layout Standard
Based on the characterization given by Talbi 
\begin_inset CommandInset citation
LatexCommand cite
key "Talbi-Metaheuristics_from_design_to_implementation:2009"

\end_inset

, a summary of the essential properties of optimization problems that justify
 the use of metaheuristics follows:
\end_layout

\begin_layout Itemize
Very large problem instances.
 Even though exact polynomial-time algorithms might be known for solving
 the target problem, they are too expensive due to the size of the instances.
\end_layout

\begin_layout Itemize
Problems with hard real-time constraints, where a 
\begin_inset Quotes eld
\end_inset

good solution
\begin_inset Quotes erd
\end_inset

 has to be found online.
 Metaheuristics appear as an alternative to exact algorithms in order to
 reduce the search time.
\end_layout

\begin_layout Itemize
A difficult problem of moderate size, which input instances have an intrincate
 structure.
\end_layout

\begin_layout Itemize
Optimization problems with time-consuming objective function(s) and/or constrain
ts.
 Indeed, various real-world optimization problems are characterized by the
 huge computational cost of the objective functions.
 Several radio-network design problems fall into this category.
\end_layout

\begin_layout Itemize
Problems that cannot be solved with exhaustive search due to the non-analytical
 models on which they are based.
 These problems are defined by a black-box evaluation of the objective function
 (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:02-Black_box_optimization"

\end_inset

).
\end_layout

\begin_layout Standard
The influence of these conditions may increase in the presence of non-determinis
tic optimization models, e.g., problems with complex Monte Carlo simulations
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Creutz-Microcanonincal_monte_carlo_simulation:1983"

\end_inset

.
\end_layout

\begin_layout Standard
Undoubtedly, metaheuristics are rapidly gaining popularity as optimization
 problems are increasing in both size and complexity.
 Indeed, as the computing power of commodity hardware increases, the possibility
 of building models of greater complexity is available for developing more
 accurate models of real-world problems in engineering and science.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Related literature groups metaheuristic algorithms due to their behaviour,
 for example:
\end_layout

\begin_layout Itemize
differential evolution, from the family of evolutionary algorithms;
\end_layout

\begin_layout Itemize
differential ant-stigmergy algorithm, from the family of swarm-intelligence
 algorithms; and
\end_layout

\begin_layout Itemize
simulated annealing, from the group of classic metaheuristic algorithms.
 
\end_layout

\begin_layout Standard
Each of these algorithms minimize an objective-function value by adopting
 essentially distinct approaches.
 In the following sections, a short description about their functioning
 is given.
\end_layout

\begin_layout Subsection
Differential evolution 
\begin_inset CommandInset label
LatexCommand label
name "sub:02-DE"

\end_inset


\end_layout

\begin_layout Standard
Differential Evolution
\begin_inset space ~
\end_inset

(DE
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "DE"
description "Differential evolution."

\end_inset

)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "storn1997_Differential_evolution"

\end_inset

 is a simple and powerful evolutionary algorithm proposed for numerical
 optimization.
 The version of DE used for this thesis is known as DE/rand/1/bin, or "classic
 DE"
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Price-Differential_evolution_a_practical_approach:2005"

\end_inset

.
 At the beggining, the classic DE initializes a population of 
\begin_inset Formula $N$
\end_inset

, 
\begin_inset Formula $D$
\end_inset

-dimensional vectors with parameter values that are distributed with random
 uniformity between pre-specified lower and upper initial parameter bounds,
 
\begin_inset Formula $x_{i,\mathrm{{low}}}$
\end_inset

 and 
\begin_inset Formula $x_{i,\mathrm{{high}}}$
\end_inset

, respectively
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Ronkkonen-Real_parameter_optimization_with_differential_evolution:2005"

\end_inset

, i.e.:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{multline}
x_{i,j,g}=x_{i,\mathrm{{low}}}+\mathrm{{uniform}[0,1)}\cdot(x_{i,\mathrm{{high}}}-x_{i,\mathrm{{low}}}),\\
i=(1,2,...,D),\, j=(1,2,...,N),\, g=0.\label{eq:02-DE_structure}
\end{multline}

\end_inset


\end_layout

\begin_layout Standard
\noindent
In Equation
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "eq:02-DE_structure"

\end_inset

, 
\begin_inset Formula $g$
\end_inset

 denotes the generation index, while 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $j$
\end_inset

 indicate the parameter and population indices, respectively.
 Consequently, 
\begin_inset Formula $x_{i,j,g}$
\end_inset

 is the 
\begin_inset Formula $i^{\mathrm{th}}$
\end_inset

 parameter of the 
\begin_inset Formula $j^{\mathrm{th}}$
\end_inset

 population vector in generation 
\begin_inset Formula $g$
\end_inset

.
 The (pseudo)-random number generator 
\begin_inset Formula $\mathrm{{uniform}[0,1)}$
\end_inset

 is represented by a function for selecting a uniformly-distributed random
 number from the interval 
\begin_inset Formula $[0,1)$
\end_inset

.
\end_layout

\begin_layout Standard
DE generates solutions by applying the mutation and cross-over operations.
 A vector from the current population is mutated by adding the scaled difference
 of two other vectors from the same population, combined with the mutation-scale
 factor.
 A proportion of the parameters of the mutated vector are crossed with those
 belonging to the 
\begin_inset Formula $j^{\mathrm{th}}$
\end_inset

 population vector, resulting in a new solution vector.
 The cross-over constant controls the proportion of parameters that the
 mutant vector contributes to the new vector.
\end_layout

\begin_layout Standard
The generated solution vector is retained if it yields a lower objective-functio
n value than the 
\begin_inset Formula $j^{\mathrm{th}}$
\end_inset

 population vector, otherwise the 
\begin_inset Formula $j^{\mathrm{th}}$
\end_inset

 vector is kept for at least one more generation.
\end_layout

\begin_layout Standard
An extensive description of DE and its variants may be found in
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "price2005differential_evolution"

\end_inset

.
 A wide range of optimization problems have been solved by applying DE
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "das2010_differential_evolution_state_of_the_art"

\end_inset

, also in the area of radio-network optimization
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Benedicic_Balancing_downlink_uplink_soft_handover_areas_in_UMTS_networks:2012,DaSilva-Analysis_of_parameter_settings_for_differential_evolution:2008,Mendes-A_differencial_evolution_algorithm_to_optimize_the_radio_network_design:2006"

\end_inset

.
\end_layout

\begin_layout Subsection
Differential ant-stigmergy algorithm 
\begin_inset CommandInset label
LatexCommand label
name "sub:02-DASA"

\end_inset


\end_layout

\begin_layout Standard
The Differential Ant-Stigmergy Algorithm
\begin_inset space ~
\end_inset

(DASA
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "DASA"
description "Differential ant-stigmergy algorithm."

\end_inset

)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "korosec2010_DASA"

\end_inset

 is based on the metaheuristic Ant-Colony Optimization (ACO
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "ACO"
description "Ant-colony optimization."

\end_inset

)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "dorigo2006ant_colony_optimization"

\end_inset

.
 ACO was pioneered by Dorigo in 1992 and is based on the foraging behaviour
 of social ants, which use pheromone as a chemical messenger.
 When looking for a food source, a swarm of ants interacts in their local
 environment.
 An ant is able to follow the route marked with pheromone laid by other
 ants.
 When an ant finds a food source, it will mark the trail to and from it
 with pheromone.
\end_layout

\begin_layout Standard
The pheromone concentration, 
\begin_inset Formula $p$
\end_inset

, evaporates at a constant rate, 
\begin_inset Formula $\gamma$
\end_inset

 , over time, 
\begin_inset Formula $t$
\end_inset

, i.e.:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
p(t)=p_{0}e^{-\gamma t},\label{eq:02-ACO_structure}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $p_{0}$
\end_inset

 is the initial pheromone concentration at 
\begin_inset Formula $t=0$
\end_inset

.
 The evaporation is important, as it provides the means for algorithm convergenc
e and self-organization.
\end_layout

\begin_layout Standard
The pheromone concentration varies over time and the ants follow the route
 with higher concentration.
 In turn, the pheromone concentration increases with the number of ants.
 That is, as more and more ants follow the same route, it becomes the favored
 path, producing a positive feedback mechanism.
 Consequently, as the system evolves in time, it converges to a self-organized
 state, which is the essence of any ant-based algorithm.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
As it was mentioned before, DASA is an ant-based algorithm that provides
 a framework to successfully cope with high-dimensional numerical optimization
 problems.
 It creates a fine-grained discrete form of the search space, representing
 it as a graph.
 This graph is then used as the walking paths for the ants, which iteratively
 improve the temporary best solution.
 
\end_layout

\begin_layout Standard
At the end of every iteration, and after all the ants have created solutions,
 they are evaluated to establish if any of them is better than the best
 solution found so far.
\end_layout

\begin_layout Standard
There are six parameters that control the way DASA explores the search space:
 the number of ants, the discrete base, the pheromone dispersion factor,
 the global scale-increasing factor, the global scale-decreasing factor,
 and the maximum parameter precision.
\end_layout

\begin_layout Standard
A more in-depth explanation about these parameters and the DASA algorithm
 itself can be found in
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "korosec2010_DASA"

\end_inset

.
\end_layout

\begin_layout Subsection
Simulated annealing 
\begin_inset CommandInset label
LatexCommand label
name "sub:02-SA"

\end_inset


\end_layout

\begin_layout Standard
This metaheuristic was introduced in the area of combinatorial optimization
 by Kirkpatrick et al.
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Kirkpatrick_OptimizationBySimulatesAnnealing"

\end_inset

.
 The algorithm resembles the physical annealing process, where particles
 of a solid material arrange themselves into a thermal equilibrium.
 Simulated Annealing
\begin_inset space ~
\end_inset

(SA
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "SA"
description "Simulated annealing."

\end_inset

) is based on the principle of local-search heuristics, and uses a pre-defined
 neighborhood structure on the search space 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Omega$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
.
 The temperature parameter controls the search behavior.
 Its name follows the analogy to the physical annealing process.
 In each iteration, a solution 
\begin_inset Formula $y$
\end_inset

, which is a neighbour of the current solution 
\begin_inset Formula $x$
\end_inset

, is computed.
 If 
\begin_inset Formula $y$
\end_inset

 has a better objective-function value than 
\begin_inset Formula $x$
\end_inset

, it becomes the new solution, i.e., the current solution 
\begin_inset Formula $x$
\end_inset

 is replaced by 
\begin_inset Formula $y$
\end_inset

.
 If, on the other hand, 
\begin_inset Formula $y$
\end_inset

 has a worse objective-function value than 
\begin_inset Formula $x$
\end_inset

, it is only accepted with a certain probability depending on two factors:
 
\end_layout

\begin_layout Itemize
the difference of the objective-function values of 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

, and
\end_layout

\begin_layout Itemize
the temperature parameter.
 
\end_layout

\begin_layout Standard
Intensification in SA is provided by the local-search nature of the algorithm,
 while diversification is produced with non-zero temperatures, by ‘‘uphill’’
 moves.
 The pseudo-code of the SA metaheuristic can be represented as in Algorithm
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "alg:07-SA_pseudocode"

\end_inset

.
 In this pseudo-code, 
\begin_inset Formula $T_{1},T_{2},...$
\end_inset

 represent an usually decreasing sequence of values for the temperature
 parameter, and 
\begin_inset Formula $\mathrm{{uniform}[0,1]}$
\end_inset

 is a function for selecting a uniformly-distributed random number from
 the given interval.
 whereas the meaning of the rest of the symbols is as defined above.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Pseudo-code of the simulated-annealing metaheuristic, adapted from
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Bianchi-A_survey_on_metaheuristics_for_stachastic_combinatorial_optimization:2009"

\end_inset

.
\shape italic

\begin_inset CommandInset label
LatexCommand label
name "alg:07-SA_pseudocode"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Require $x 
\backslash
gets$ initial solution
\end_layout

\begin_layout Plain Layout


\backslash
Require $T_{
\backslash
mathrm{1}} 
\backslash
gets$ temperature parameter
\end_layout

\begin_layout Plain Layout


\backslash
For {k=1,2,...}
\end_layout

\begin_layout Plain Layout

	
\backslash
State $y 
\backslash
gets$ random solution from $
\backslash
Omega$
\end_layout

\begin_layout Plain Layout

	
\backslash
If {$f(y) 
\backslash
le f(x)$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $x 
\backslash
gets y$
\end_layout

\begin_layout Plain Layout

	
\backslash
ElsIf {$e^{(
\backslash
frac{f(x)-f(y)}{T_{k}})} 
\backslash
le 
\backslash
mathrm{uniform}[0,1]$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $x 
\backslash
gets y$
\end_layout

\begin_layout Plain Layout

	
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
State $T_{k+1} 
\backslash
gets$ update temperature $T_{k}$
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
SA has proved to be a solid optimization algorithm, capable of giving high-quali
ty solutions to a wide scope of optimization problems
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Suman_SurveyOfSimulatedAnnealing"

\end_inset

.
 Additionally, several works employ the SA metaheuristic for solving optimizatio
n problems in the area of radio network
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Benedicic_Balancing_downlink_uplink_soft_handover_areas_in_UMTS_networks:2012,Duque-Channel_assignment_for_cellular_radio_using_simulated_annealing:1993,CPICH.optimization:2003,minimum.set.covering.problem:2000,Coverage.optimization.on.CPICH.tilt.and.azimuth:2006,Zhang-Mathematical_modelling_and_comparisons_of_heuristics_for_WCDMA_radio_planning:2006"

\end_inset

.
\end_layout

\begin_layout Section
Black-box optimization 
\begin_inset CommandInset label
LatexCommand label
name "sub:02-Black_box_optimization"

\end_inset


\end_layout

\begin_layout Standard
The complexity of a problem is equivalent to the complexity of the best
 known algorithm solving that problem
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Talbi-Metaheuristics_from_design_to_implementation:2009"

\end_inset

.
 If there exists a polynomial-time algorithm to solve a problem, the problem
 is said to be easy or tractable.
 Similarly, if a problem is difficult or intractable, there is no known
 polynomial-time algorithm to solve it.
 
\end_layout

\begin_layout Standard
Many optimization problems cannot be formulated with a clear analytical
 mathematical notation.
 In such cases, the objective function may become a black box 
\begin_inset CommandInset citation
LatexCommand cite
key "Kargupta-Search_blackbox_optimization_and_sample_complexity:1996"

\end_inset

.
 This is one of the main advantages when using metaheuristics, i.e., there
 is no need of a complete knowledge of the targeted model.
 Indeed, in a black-box optimization, no analytical formulation of the objective
 exists 
\begin_inset CommandInset citation
LatexCommand cite
key "Talbi-Metaheuristics_from_design_to_implementation:2009"

\end_inset

, as Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:02-black_box_optimization"

\end_inset

 shows.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/blackbox_optimization.eps
	lyxscale 90
	width 55text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A metaheuristic algorithm process using a black box for the objective-function
 evaluation, 
\begin_inset Formula $f(x)$
\end_inset

, of a solution, 
\begin_inset Formula $x$
\end_inset

.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:02-black_box_optimization"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
More specifically, a function 
\begin_inset Formula $f(\vec{x})$
\end_inset

, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\vec{x}\in\mathbb{R}^{n}$
\end_inset

,
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 is a black-box function if and only if
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Talbi-Metaheuristics_from_design_to_implementation:2009"

\end_inset

:
\end_layout

\begin_layout Itemize
the domain 
\begin_inset Formula $\vec{x}$
\end_inset

 is known,
\end_layout

\begin_layout Itemize
it is possible to get the value of 
\begin_inset Formula $f$
\end_inset

 for each 
\begin_inset Formula $\vec{x}$
\end_inset

 based on simulation, and
\end_layout

\begin_layout Itemize
there is no other information available for function 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Standard
Typically, the experiments associated with these kind of problems are very
 expensive in terms of time and cost, since a simulation must be forced
 to evaluate the solution.
 Generally speaking, the most time-consuming part of a metaheuristic optimizatio
n process is the evaluation of the objective function
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Talbi_Metaheuristics:2009"

\end_inset

.
 This is especially true when dealing with real-world problems of areas
 such as structural design
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Barthelemy-Approximation_concepts_for_optimum_structural_design:1993"

\end_inset

, molecular docking
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Tantar-A_parallel_hybrid_genetic_algorithm_for_protein_structure_prediction:2007"

\end_inset

 and, the field on which this thesis focuses, radio-network design
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Benedicic_Pilot.power.optimization:2010,Benedicic_Balancing_downlink_uplink_soft_handover_areas_in_UMTS_networks:2012,Benedicic-A_GPU_based_parallel_agent_optimization_approach:2013,Benedicic-A_GRASS_GIS_parallel_module_for_radio-propagation_predictions:2013,Benedicic-An_adaptable_parallel_simulation_framework_for_LTE_coverage_planning:2013"

\end_inset

.
 A possible subtitution for lenghty evaluations is to reduce their complexity
 by approximating the objective function, thus replacing it with an approximatio
n during the optimization process.
 This approach is known as meta-modeling
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Talbi_Metaheuristics:2009"

\end_inset

.
 However, when dealing with approximations, some degree of solution quality
 is inevitably sacrified.
 As it will be shown in the following chapters, there is a very fine balance
 between the number of evaluations and the quality of the achieved solutions.
 Consequently, reducing the time spent in objective-function evaluation
 should favorably influence the solution quality achieved by a preferred
 metaheuristic algorithm.
 A major portion of this thesis is dedicated to improve this specific aspect
 in the area of radio-network optimization, starting with a high-performance,
 unified framework for radio-network planning, which is presented in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:04-Framework-design-and-implementation"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
In practice, however, the black-box evaluation of the objective function
 presents a problem.
 In the context of research about radio-network optimization there is an
 inherent difficulty of providing the black-box used to evaluate a given
 approach.
 A quick review of the state-of-the-art in radio-network optimization indicates
 that this fact has become increasingly regular in several published works
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "amaldi2007radio_planning,chen2008automated,chen2009fast,gordejuela2009two,siomina2008enhancing,siomina2007minimum_pilot_power"

\end_inset

.
 Clearly, this fact creates a barrier to one of the most important phases
 of scientific methodology: experimental reproducibility
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "gauch2002scientific"

\end_inset

.
 
\end_layout

\begin_layout Standard
There are several reasons behind this situation.
 For example, it is a known fact that proprierary software, providing good
 computational models for radio-network simulation, is a very expensive
 tool for science.
 Even neglecting the economical aspect, but considering the great variety
 of software packages and license combinations, it is practically impossible
 for a research laboratory to have the whole pallete of commercially-available
 solutions at its disposal.
 Moreover, genuine users of these applications are generally not allowed
 to mention the formats, protocols, or algorithms used by the proprietary
 software, since their disclosure is often explicitly forbidden by restrictive
 licenses.
\end_layout

\begin_layout Standard
Some non-commercial and open-source packages for radio-network simulation
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Mehlfuhrer_The_Vienna_LTE_Simulators_enabling_reproducibility_in_wireless_communications_research:2011,Momentum.project,Ozimek_Open.source.radio.coverage.prediction:2010,Pillekeit-A_hybrid_simulation_framework_for_the_evaluation_of_common_RRM:2012,Piro_Simulating_LTE_cellular_systems_an_open_source_framework:2011,Yeung-Detailed_OFDM_modeling_in_network_simulation:2004"

\end_inset

 present two main drawbacks: poor documentation and/or low scalability.
 The scalability issues shown by some projects retrain these packages to
 be used in larger, real-world environments, where big problem instances
 are the rule.
 Despite this, the merit and acknowledgement go the authors of these frameworks,
 not only for providing them to the scientific community, but fundamentaly
 because for providing an environment in which different kinds of simulations
 are completely reproducible.
 Additionally, the lack of documentation represents a big hurdle for extending
 the base code, which becomes a difficult task without the help of the original
 authors of the package.
 In such cases, author's knowledge is required for effectivelly expanding
 the functionality of an open-source tool.
 This is especially true when dealing with complex simulation frameworks,
 as the ones used for radio networks.
\end_layout

\begin_layout Chapter
Principles of mobile radio networks 
\begin_inset CommandInset label
LatexCommand label
name "chap:02-Principles_of_mobile_radio_networks"

\end_inset


\end_layout

\begin_layout Standard
A cellular mobile radio network is a collection of individual cells that
 are served by several transmitters, called Base Stations
\begin_inset space ~
\end_inset

(BSs
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "BSs"
description "Base station."

\end_inset

).
 Each BS gives radio coverage to a small geographical area.
 The integration of the coverage of various BSs provides radio coverage
 over a much larger geographical area, thus defining a cellular radio network.
 The two basic functions of a radio-network system are: 
\end_layout

\begin_layout Itemize
locate and track both active and idle mobile devices, called User Equipments
\begin_inset space ~
\end_inset

(UEs
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "UE"
description "User equipment."

\end_inset

); and
\end_layout

\begin_layout Itemize
attempt to connect each UE to the best available BS.
\end_layout

\begin_layout Standard
The first task involves a location-update procedure, which allows an UE
 to inform the network about its movement from one location area to the
 next.
 This process is called mobility management.
 The second task requires the constant evaluation of the radio-link quality
 with the serving BS, and the radio-link qualities of alternate BSs.
 This process is called radio-resource management, and is performed by the
 network using knowledge about the link-quality evaluations of the reference
 channels, e.g., the pilot channels.
\end_layout

\begin_layout Standard
The radio communications between an UE and a grid of BSs use low power.
 However, the movement of the UE causes highly irregular radio-link conditions,
 thus consistent monitoring and precise control are required to keep the
 radio-link quality at an acceptable level.
 At the core of the evaluation of radio-link quality is a statistical-measuremen
t process based on a previous knowledge of the expected characteristics
 of the pilot channel.
 On the one hand, the link quality, and the size and distribution of the
 cells of a modern radio cellular system are limited by the speed of the
 link-quality measurement and network control.
 On the other hand, the spectral efficiency of a radio network is bounded
 by the cell sizes, the ability of radio links to withstand interference,
 and the ability of the system to react to variations in traffic
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Stuber-Principles_of_mobile_communication:2011"

\end_inset

.
\end_layout

\begin_layout Standard
Cellular radio systems partition the available spectrum among the BSs, and
 a given frequency is reused at the closest possible distance that the radio
 link will allow.
 Consequently, smaller cells have a shorter distance between reused frequencies,
 and this results in an increased spectral efficiency and traffic-carrying
 capacity.
 The radio links of a high-capacity radio network interfere with each other
 due to frequency reuse.
 For this reason, it is always desirable to use the lowest possible transmit
 power while maintaining each radio link above a given Quality-of-Service
\begin_inset space ~
\end_inset

(QoS
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "QoS"
description "Quality of service."

\end_inset

) threshold.
 Therefore, radio links should not significantly exceed their target QoS,
 since doing so will cause unnecessary interference to other radio links
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Stuber-Principles_of_mobile_communication:2011"

\end_inset

.
 This particular situation is further discussed in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:06-Experimental-evaluation-the-service-coverage-problem"

\end_inset

, where an optimization approach, that minimizes the total transmit power
 used in a radio network, is presented.
\end_layout

\begin_layout Section
Handover 
\begin_inset CommandInset label
LatexCommand label
name "sub:02-Handover-and-soft-handover"

\end_inset


\end_layout

\begin_layout Standard
In radio networks, handover (or handoff) is one of the main features that
 allows the mobility of UEs
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "WCDMAforUMTS_RadioAccessForThirdGenerationMobileCommunications"

\end_inset

.
 The concept behind the handover operation is simple: when a UE moves from
 the coverage area of a cell to the coverage area of a neighboring cell,
 the system creates a new connection with the latter cell and disconnects
 the user from the former one, so that an acceptable link quality can be
 maintained.
 Otherwise, the increase in transmit power, that is required to compensate
 for path loss, results in excessive interference.
 The handover procedure consists of two processes
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Stuber-Principles_of_mobile_communication:2011"

\end_inset

:
\end_layout

\begin_layout Itemize
the link-quality evaluation before handover initiation, and
\end_layout

\begin_layout Itemize
the allocation of radio and network resources.
\end_layout

\begin_layout Standard
Generally speaking, radio networks with smaller cell sizes require faster
 and more reliable handover algorithms.
 Indeed, it has been shown that the number of cell-boundary crossings is
 inversely proportional to the cell size
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Labedz-Handover_control_issues:1987"

\end_inset

.
 Since there is certain probability of dropping a connection whenever a
 handover is attempted, it is clear that the role of handover configuration
 becomes more important as the cell sizes decrease.
 Therefore, if the radio network does not detect poor signal quality fast
 enough, or makes too many handovers, the capacity is diminished due to
 increased interference and/or excessive control traffic
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Stuber-Principles_of_mobile_communication:2011"

\end_inset

.
\end_layout

\begin_layout Subsection
Hard handover
\end_layout

\begin_layout Standard
During a hard handover, an UE can connect to only one BS at a time.
 A unique decision initiates and executes a handover without making a number
 of simultaneous connections among candidate BSs.
 Based on link measurements, the target BS is selected prior to executing
 the handover, and the active connection is instantly transferred to it.
 Moreover, the connection even experiences a brief interruption during the
 actual transfer, because the UE can only connect to one BS at a time.
 In contrast to soft handover (see next section), hard handovers do not
 take advantage of the diversity gain, where the signals from two or more
 BSs arrive at comparable strengths.
 Hard handover is a simple and inexpensive way to support UE mobility.
 It is used in Time-Division, Multiple-Access (TDMA
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "TDMA"
description "Time division multiple access."

\end_inset

) cellular systems such as GSM
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Stuber-Principles_of_mobile_communication:2011"

\end_inset

.
\end_layout

\begin_layout Subsection
Soft handover
\end_layout

\begin_layout Standard
Soft Handover
\begin_inset space ~
\end_inset

(SHO
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "SHO"
description "Soft handover."

\end_inset

) enhances handover functionality by allowing an UE to potentially operate
 on multiple radio links at a time.
 During SHO, the target BS is selected as the best candidate from among
 the available BSs.
 The UE performs the necessary link-quality measurements by monitoring the
 signals from the surrounding BSs.
 Simultaneously keeping multiple connections means that SHO enhances the
 system performance through diversity reception.
\end_layout

\begin_layout Standard
Despite the advantages it provides, SHO is complex and expensive to implement.
 Additionally, interference actually increases with SHO, since several BSs
 can connect to the same UE.
 This increase in forward interference can become a problem.
 If the handover region is large, such that there are many UEs in SHO mode,
 the increased interference due to several BSs connected to the same UE
 can become a problem
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Stuber-Principles_of_mobile_communication:2011"

\end_inset

.
\end_layout

\begin_layout Standard
The SHO procedure is important in systems using the channel-access method
 known as Code Division Multiple Access
\begin_inset space ~
\end_inset

(CDMA
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "CDMA"
description "Code division multiple access."

\end_inset

), and especially in Wide CDMA
\begin_inset space ~
\end_inset

(WCDMA
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "WCDMA"
description "Wide-code division multiple access."

\end_inset

), which is employed by the UMTS.
 CDMA systems are interference-limited meaning their capacities are closely
 related to the level of interference they can tolerate.
 Specifically, a CDMA system cell is affected by the interference within
 its own cell, and also interference from its neighboring cells.
 In order to mitigate the level of interference, and thus increase the capacity
 and quality, CDMA systems use power control.
 The main idea behind power control is to prevent the UEs and the BSs from
 transmitting more power than is strictly necessary to meet the target QoS
 level.
 For the power control to work properly, the system must ensure that each
 UE is connected to the BS having the least attenuation at all times.
 If this is not the case, a positive-feedback problem appears, and it can
 potentially destabilize the entire system
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Wong-Soft_handoffs_in_CDMA_mobile_systems:1997"

\end_inset

.
 The SHO procedure helps to prevent such situations by ensuring that each
 UE is served by the best BS most of the time, i.e., by allowing connections
 to multiple BSs.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/soft_handover.png
	lyxscale 50
	width 40text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Example of two UEs in soft handover with two BSs.
 Adapted from [219???].
 
\begin_inset CommandInset label
LatexCommand label
name "fig:02-SHO_example"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The SHO condition depends on the relative, received-signal quality from
 different cells and the SHO window, which triggers the addition of a cell
 to the active set of the UE.
 Depending on radio propagation characteristics, the radio transmission
 can gain more than 3
\begin_inset space ~
\end_inset

dB out of a SHO situation 
\begin_inset CommandInset citation
LatexCommand cite
key "WCDMAforUMTS_RadioAccessForThirdGenerationMobileCommunications"

\end_inset

.
 From this point of view, SHO is a method to reduce interference and improve
 radio quality, particularly at the cell border where the radio coverage
 is of inferior quality.
 In UMTS Release 99 
\begin_inset CommandInset citation
LatexCommand cite
key "3GPP_R99"

\end_inset

, SHO is specified to work from the BS towards the UE (downlink), and from
 the UE towards the BS (uplink).
\end_layout

\begin_layout Standard
With the introduction of the High Speed Packet Access
\begin_inset space ~
\end_inset

(HSPA
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "HSPA"
description "High Speed Packet Access."

\end_inset

) as an improvement of the performance existing in WCDMA protocols, the
 role SHO plays in mobile network configuration and functioning slightly
 changed.
 The key difference is that the High Speed Downlink Packet Access
\begin_inset space ~
\end_inset

(HSDPA
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "HSDPA"
description "High Speed Downlink Packet Access."

\end_inset

) does not support SHO, whereas the High Speed Uplink Packet Access
\begin_inset space ~
\end_inset

(HSUPA
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "HSUPA"
description "High Speed Uplink Packet Access."

\end_inset

) does.
 This particular distinction is further discussed in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:07-Experimental-evaluation-the-SHO-alignment-problem"

\end_inset

, because it has some important implications in the balanced distribution
 of SHO areas, and thus in the quality and capacity of HSPA services
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "holma2006hsdpa"

\end_inset

.
\end_layout

\begin_layout Section
Pilot signal and power 
\begin_inset CommandInset label
LatexCommand label
name "sub:02-Pilot-signal-and-power"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Explicar que es esto y como funciona en el resto de la tesis
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The CPICH transmit power is typically between 5% to 10% of the total downlink
 transmit power of the base station 
\begin_inset CommandInset citation
LatexCommand cite
key "RadioNetworkPlanningAndOptimisationForUMTS"

\end_inset

, but there is no standardized method to ﬁnd a CPICH power setting.
\end_layout

\begin_layout Standard
The CPICH transmits in the downlink of a UMTS cell system.
 The transmit power is usually between 5% and 10% of the total power available
 at the base station 
\begin_inset CommandInset citation
LatexCommand citep
key "Holma_WCDMA.for.UMTS:2005"

\end_inset

.
 The capacity of a cell is limited by the amount of available power at the
 base station and the interference level at the mobile terminal.
 The coverage area of any cell is controlled by changing its pilot power,
 which consequently modifies the service area of the network.
\end_layout

\begin_layout Standard
The CPICH transmit power is common to many different planning and optimization
 problems in UMTS networks 
\begin_inset CommandInset citation
LatexCommand citep
key "Nawrocki_Understanding:2006"

\end_inset

.
\end_layout

\begin_layout Chapter
Overview of radio-network optimization 
\begin_inset CommandInset label
LatexCommand label
name "chap:02-Optimization_of_radio_networks"

\end_inset


\end_layout

\begin_layout Standard
Once a radio network is launched, an important part of its operation and
 maintenance deals with monitoring its quality characteristics.
 With the evolution of mobile communications, the complexity of network
 planning has grown along with its throughput capacity, thus making it practical
ly impossible to plan modern radio networks with traditional methods.
 In this sense, an examination of coloured coverage maps in conjunction
 with some statistical analysis are no longer appropriate tools for troubleshoot
ing a network.
 Moreover, since real-world radio networks are large and many of their configura
tion parameters are interdependent, an engineer is not able to cope with
 the level of complexity present in these systems.
 For this reason, the computer, along with specialized software, guides
 the engineer to the most appropriate configuration for the network.
 In the context of this thesis, this process is refered to as radio-network
 optimization.
\end_layout

\begin_layout Standard
Radio-network optimization may be divided into two fundamental phases: analysis
 and decision
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Nawrocki-Understanding_UMTS_radio_network_modelling_and_optimisation:2006"

\end_inset

.
 The analysis phase consists on the examination of the network performance,
 which mainly focuses on the definition and collection of Key-Performance
 Indicators (KPIs
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "KPI"
description "Key performance indicator."

\end_inset

).
 KPIs are quantifiable measurements that reflect different network-quality
 factors.
 The second phase deals with the decision making, based on the analytical
 results collected in the previous phase, about changing a particular configurat
ion or parameter setting.
 The process, a representation of which is depicted in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Optimization-cycle"

\end_inset

, is repeated until the achieved results are acceptable.
 Notice the similarity with the general, decision-making process that was
 presented in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:01-Introduction"

\end_inset

, Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:01-decision_making_process"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/optimization_cycle.eps
	width 40text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A typical optimization cycle for radio networks.
 This sequence is repeated until the achieved results are acceptable.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Optimization-cycle"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Since radio networks are increasingly more sophisticated, the need for optimizat
ion methods that are capable of copeing with greater complexity is far from
 declining.
 Indeed, several radio-network optimization problems were shown to be NP-hard,
 since the computational time grows non-polynomially with the problem size
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Amaldi-Planning_UMTS_base_station_locations:2003,Amaldi-Radio_planning_and_coverage_optimization_of_3G_networks:2008,Gordejuela-LTE_access_network_planning_and_optimization:2009,Han-Optimizing_cell_size_for_energy_saving_in_cellular_networks:2012,Lee-Proportional_fair_frequency_domain_packet_scheduling_for_LTE_uplink:2009,Razavi-Performance_improvement_of_LTE_tracking_area_design:2008,Siomina-Minimum_pilot_power_for_service_coverage:2007"

\end_inset

.
 As described in
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Nawrocki-Understanding_UMTS_radio_network_modelling_and_optimisation:2006"

\end_inset

, there are other reasons directly related with the growth of already deployed
 networks that also increase the need for optimization methods:
\end_layout

\begin_layout Description
Network
\begin_inset space ~
\end_inset

performance
\begin_inset space ~
\end_inset

improvement more users receive service coverage with the same physical infrastru
cture, making parameter optimization the less expensive and only viable
 short-term approach.
\end_layout

\begin_layout Description
Changes
\begin_inset space ~
\end_inset

in
\begin_inset space ~
\end_inset

user
\begin_inset space ~
\end_inset

profile the introduction of new, faster services puts additional stress
 on the infrastructure, requiring additional optimization efforts.
\end_layout

\begin_layout Description
Changes
\begin_inset space ~
\end_inset

in
\begin_inset space ~
\end_inset

the
\begin_inset space ~
\end_inset

propagation
\begin_inset space ~
\end_inset

conditions the allocation of different frequency bands for different systems,
 e.g., GSM, UMTS or LTE, requires the deployment of new BSs, the radio propagation
s of which behave differently, especially in urban areas.
\end_layout

\begin_layout Standard
Depending on the optimization problem being addressed, network operators
 define an optimization target that is represented by an objective function
 that maps possible configurations into a real value.
 Unfortunately, there is no universal objective function in the field of
 radio-network optimization
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Nawrocki-Understanding_UMTS_radio_network_modelling_and_optimisation:2006"

\end_inset

.
 However, it is possible to optimize for a different target at a time, such
 as service coverage, SHO balance or signal propagation.
 Particular optimization algorithms for solving these problems are presented
 in Chapters
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:06-Experimental-evaluation-the-service-coverage-problem"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:07-Experimental-evaluation-the-SHO-alignment-problem"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:05-Framework_parameter_tuning"

\end_inset

, respectively.
 In all three cases, the introduced optimization approaches are performed
 
\begin_inset Quotes eld
\end_inset

offline
\begin_inset Quotes erd
\end_inset

, meaning that the optimization software is not an active part of the target
 radio network.
 As the feedback information of each optimization target, the statistical
 data about the network functioning is used.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
In the following, an overview of some well-known optimization problems for
 radio-mobile networks is given.
 Each section describes an optimization problem, and presents a short survey
 of recently proposed optimization methods for solving them.
\end_layout

\begin_layout Section
Optimizing base-station locations
\end_layout

\begin_layout Standard
Some authors
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "minimum.set.covering.problem:1997,minimum.set.covering.problem:2000"

\end_inset

 formulate the problem of locating BSs in terms of the minimum set-covering
 problem (see Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:02-Minimum_set_covering_problem"

\end_inset

).
 The set-covering problem is defined by considering the signal level in
 every test point from all BSs and requiring that at least one level is
 above a fixed threshold.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/set_cover_in.gif
	lyxscale 50
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/set_cover_out.gif
	lyxscale 50
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
(b)
\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
A graphical representation of the set-covering problem: (a) the problem
 input and (b) the solution.
\begin_inset CommandInset label
LatexCommand label
name "fig:02-Minimum_set_covering_problem"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A different formulation considers the BS-site location problem as a 
\emph on
p
\emph default
-median problem
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Yang-UMTS_base_station_location_planning:2007"

\end_inset

, in which the BS location is the only decision variable considered.
 To each of the candidate solutions, an installation cost is also associated.
 The 
\emph on
p
\emph default
-median problem constitutes seeking 
\emph on
p
\emph default
 different locations each time, regardless of how distant the sites are.
 The problem involves selecting one installation-candidate site from each
 region such that the traffic capacity and the size of the covered area
 of the network are maximized with the lowest installation cost.
\end_layout

\begin_layout Subsection
Related work
\end_layout

\begin_layout Standard
Aydin et al.
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Aydin:Heuristic.Optimization.Of.WCDMA"

\end_inset

 proposed a solution to the 
\begin_inset Formula $p$
\end_inset

-median problem based on three metaheuristic algorithms: a genetic algorithm,
 SA, and tabu search.
 Their experimental study focused on the performance comparison between
 the three approaches.
\end_layout

\begin_layout Standard
In
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Yang-UMTS_base_station_location_planning:2007"

\end_inset

, the authors also used a simplified 
\begin_inset Formula $p$
\end_inset

-median problem as the model.
 They presented the results of extensive simulations to compare the performance
 of three different metaheuristic algorithms.
\end_layout

\begin_layout Standard
A solution to the set covering problem is proposed by Hao et al.
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "minimum.set.covering.problem:1997"

\end_inset

.
 An implementation of SA was developed to solve the formulated combinatorial
 problem.
 The presented results showed the feasibility of the proposed approach.
 
\end_layout

\begin_layout Standard
Mathar and Niessen
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "minimum.set.covering.problem:2000"

\end_inset

 proposed a hibrid method that combines a linear-programming approach with
 SA.
 The SA algorithm substituted linear programming whenever an exact solution
 was out of reach because of the complexity of the problem instance.
\end_layout

\begin_layout Standard
Amaldi et al.
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Amaldi-Planning_UMTS_base_station_locations:2003"

\end_inset

 presented a discussion about the computational results of two different
 heuristics: greedy search and tabu search.
 The problem formulation was based on a set of candidate sites where the
 BSs could be installed, an estimation of the traffic distribution and a
 propagation description of the area to be covered.
 Some years later, the same authors
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Amaldi-Radio_planning_and_coverage_optimization_of_3G_networks:2008"

\end_inset

 extended the problem formulation by adding the BS configuration and the
 hardware characteristics as additional constraints of the integer program.
 In both works, they proposed a mixed, integer-programming model to maximize
 the trade-off between covered area and installation costs.
\end_layout

\begin_layout Standard
Finally, Whitaker et al.
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "GA.for.antenna.placement:2005"

\end_inset

 focused on providing a required service-coverage target at the lowest possible
 financial cost.
 Their work compared the performance of four different algorithms, namely
 SEAMO, SPEA2, NSGA-II and PESA, all targeting multiobjective optimization
 targets.
\end_layout

\begin_layout Section
Optimizing antenna parameters
\end_layout

\begin_layout Standard
Since an antenna shapes the emitted energy, its configuration plays an important
 role in the coverage and interference of a radio network.
 The two most important parameters in this sense are the azimuth angle and
 the tilt (or elevation angle) of the antenna.
 The antenna azimuth, an example pattern of which is depicted in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:02-Antenna_azimuth"

\end_inset

, is the horizontal direction of the main antenna beam.
 The antenna tilt (see Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:02-Antenna-tilt"

\end_inset

) is defined as the angle of the main antenna beam relative to the horizontal
 plane.
 Both of these parameters have a great influence on network quality, although
 the antenna tilt usually requires less effort to implement, since most
 modern radio networks already support remote electrical tilt
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Athley-Impact_of_electrical_tilt_on_LTE_performance:2010"

\end_inset

.
 The adjustment of these two parameters optimize some important aspects
 of the network, e.g.:
\end_layout

\begin_layout Itemize
the path loss between the BS and the UE,
\end_layout

\begin_layout Itemize
the interference between neighboring cells, which leads to an overall capacity
 increase of the network.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/azimuth.gif
	lyxscale 40
	width 30text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
An example of an antenna-azimuth pattern.
\begin_inset CommandInset label
LatexCommand label
name "fig:02-Antenna_azimuth"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/tilt.jpg
	lyxscale 40
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The antenna tilt, showing its angle with the horizontal plane.
\begin_inset CommandInset label
LatexCommand label
name "fig:02-Antenna-tilt"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Related work
\end_layout

\begin_layout Standard
One of the approaches proposed by Gerdenitsch et al.
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Antenna.tilt.and.CPICH:2003"

\end_inset

 involves an 
\begin_inset Quotes eld
\end_inset

ad-hoc
\begin_inset Quotes erd
\end_inset

 strategy for adjusting antenna azimuth and downtilt by analyzing the structure
 of the network.
 The objective of this optimization was to improve the number of served
 users in the target area.
 
\end_layout

\begin_layout Standard
Siomina and Yuan
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Antenna.Configuration:2008"

\end_inset

 proposed an approach for automated optimization of antenna azimuth and
 tilt, including support for both mechanical and electrical tilt.
 The implementation introduced a SA-based algorithm that searches the solution
 space of feasible antenna configurations.
 The goal of the optimization was to improve power sharing among different
 cell channels and ultimately improve the throughput of the network.
\end_layout

\begin_layout Standard
In
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Antenna.azimuth.tilt:2009"

\end_inset

, the authors presented a compound optimization method containing two loops:
 the inner one and the outer one.
 The inner loop concentrated on frequency planning while the outer loop
 focused on finding the optimal settings of antenna azimuth and tilt for
 the current solution delivered by the inner loop.
 This approach is interesting because of its flexibility, e.g., the inner
 loop could be replaced with some other optimization objective, like service
 coverage.
\end_layout

\begin_layout Standard
In
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Eckhardt-Vertical_antenna_tilt_optimization_for_LTE:2011"

\end_inset

, the authors proposed an autonomous optimization approach for the antenna
 tilts.
 Based on the gradient-ascent method, the presented heuristic showed the
 fast convergence needed for an online-optimization method to be effective.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Combining the power setting of the pilot signal with the antenna configuration
 is also a common practice.
 For example, Siomina et al.
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Coverage.optimization.on.CPICH.tilt.and.azimuth:2006"

\end_inset

 present an optimization approach for maximizing the service coverage that
 combines both antenna parameters with the power of the pilot signal.
 Their SA-based algorithm searches the solution space of possible configurations
 in order to improve the performance of the target radio network by reducing
 the total interference.
 The simulation results show the algorithm is capable of tackling large
 network instances.
\end_layout

\begin_layout Standard
Two optimization algorithms for finding an optimal setting of antenna tilt
 and pilot-signal power were also introduced in the previously cited work
 by Gerdenitsch et al.
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Antenna.tilt.and.CPICH:2003"

\end_inset

.
 The first algorithm is based on a rule-based approach, while the second
 one extends it by incorporating SA.
 The evaluation of both techniques showed that the second algorithm achieves
 better solutions.
\end_layout

\begin_layout Standard
In a different work, Gerdenitsch et al.
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "GA.for.tilt.and.CPICH:2004"

\end_inset

 proposed a genetic algorithm to tackle the optimization of antenna tilt
 and pilot-signal power, the goal of which is to increase network capacity.
 The implementation involves a deterministic fitness selection scheme, a
 problem-specific recombination operator and an improved mutation operator.
 After the initial identification of the best promising individuals, a local-opt
imization technique is applied to improve their fitness.
\end_layout

\begin_layout Section
Optimizing coverage 
\begin_inset CommandInset label
LatexCommand label
name "sec:Optimizing-coverage"

\end_inset


\end_layout

\begin_layout Standard
Coverage is arguably the most common optimization objective considered in
 radio-network optimization.
 A general objective function for coverage optimization can be defined as
 follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
f_{\mathrm{cov}}=\frac{A_{\mathrm{covered}}}{A_{\mathrm{total}}},
\]

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "S"
symbol "$f_{\\mathrm{cov}}$"
description "Objective function for the service-coverage optimization problem."

\end_inset


\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "S"
symbol "$A_{\\mathrm{covered}}$"
description "Area under service coverage of the mobile network."

\end_inset


\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "S"
symbol "$A_{\\mathrm{total}}$"
description "Complete geographical area under optimization."

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $A_{\mathrm{covered}}$
\end_inset

 represents the area covered by the network and 
\begin_inset Formula $A_{\mathrm{total}}$
\end_inset

 represents the total area under optimization.
 Thus, the expression 
\begin_inset Formula $f_{\mathrm{cov}}$
\end_inset

 represents the proportion of the total area that is actually under network
 coverage, the value of which ranges from 0 (no coverage) to 1 (total coverage).
\end_layout

\begin_layout Standard
The area under optimization is usually divided into squares (or pixels)
 of a certain size, creating a Regular Square Grid (RSG
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "RSG"
description "Regular square grid."

\end_inset

) of a certain resolution.
 A pixel is considered covered if a given QoS measure is above a defined
 threshold.
 It is also common to use a binary function, e.g., 
\begin_inset Formula $cov(x,y)$
\end_inset


\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "S"
symbol "$cov(x,y)$"
description "Returns 1 if the coordinate $(x,y)$ is under mobile-network coverage."

\end_inset

, to check the coverage of a given pixel.
 The function returns 1 if the pixel located at 
\begin_inset Formula $(x,y)$
\end_inset

 is covered, and 0 otherwise.
\end_layout

\begin_layout Subsection
Related work
\end_layout

\begin_layout Standard
Siomina and Yuan
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Siomina:Minimum.pilot.power.for.service.coverage"

\end_inset

 considered the problem of minimizing the pilot-signal power subject to
 a coverage constraint.
 Their approach consists of an iterative mathematical program, based on
 a linear-integer formulation of the problem.
 The simulation results showed the trade-off between service coverage and
 power consumption for different test networks.
\end_layout

\begin_layout Standard
Almaldi et al.
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Amaldi-Radio_planning_and_coverage_optimization_of_3G_networks:2008"

\end_inset

 investigated several mathematical-programming models for supporting decisions
 on where to install new BSs and how to select their configuration in order
 to find a trade-off between coverage and costs.
 The overall model takes into account signal-quality constraints, in both
 uplink and downlink directions, as well as the pilot-signal power.
\end_layout

\begin_layout Standard
Connecting UMTS and LTE-network optimization from the coverage point of
 view, Sallent et al.
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Sallent-A_roadmap_from_UMTS_to_LTE_optimization:2011"

\end_inset

 presented a framework to automatically identify a cell with sub-optimal
 coverage.
 The framework input is a collection of KPIs, including usage statistics
 and UE field measurements.
 The authors used the experimental results to provide a projection for the
 LTE self-optimization functionality.
\end_layout

\begin_layout Standard
In
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Thampi-A_sparse_sampling_algorithm_for_self_optimisation_of_coverage_in_LTE_networks:2012"

\end_inset

, the authors introduced a sparse-sampling algorithm to optimize the coverage
 of LTE networks by means of antenna tilt.
 By applying a reinforcement-learning technique, their approach optimizes
 coverage without prior knowledge about the target network.
\end_layout

\begin_layout Standard
Parkinnen et al.
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Coverage.optimization.with.cost.function:2002"

\end_inset

 presented a gradient-descent method to minimize an objective function that
 combines some KPIs with the service coverage.
 The power of the pilot signal of the cells is periodically updated in order
 to improve the afore-mentioned function.
\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Standard
Regarding the optimization methods presented in the previous sections, three
 distinctive groups emerge: genetic algorithms, linear programming and other
 search methods.
\end_layout

\begin_layout Description
Genetic
\begin_inset space ~
\end_inset

algorithms These algorithms work on a population of solutions, allowing
 a more comprehensive search for optimal solutions.
 As a direct consequence, an increase in running time is commonly observed.
 The implementation effort of genetic algorithms is to some degree higher
 than for simpler search methods, e.g., local search, but their inherent structure
 makes parallel implementations rather simple.
 Additionally, genetic algorithms are less likely of being trapped in local
 optima, since they are a population-based metaheuristic.
\end_layout

\begin_layout Description
Linear
\begin_inset space ~
\end_inset

programming Linear-integer or mixed-integer programming are widely used
 in different optimization areas and there are many good software packages
 to solve such problems.
 Consequently, if a problem can be modeled as a continuous linear problem,
 there is usually no difficulty in finding optimality.
 In the context of this survey, linear programming has proven useful for
 BS-location optimization in early network planning stages.
\end_layout

\begin_layout Description
Other
\begin_inset space ~
\end_inset

search
\begin_inset space ~
\end_inset

methods Other search methods, e.g., local search, SA, tabu search or gradient
 descent, usually represent a compromise between running time and quality
 of results.
 Their effectiveness relies on evaluating a great number of alternative
 solutions.
 The number of parameters taken into account, as well as the evaluation
 precision, directly influence their running time.
 These methods don't excel in full simulation scenarios.
 Moreover, some of them are easily trapped in local minima.
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
The variety of optimization problems described in the previous sections
 differ in many aspect, like implementation, running time and solution quality.
 Picking the right method for a given situation depends on the optimization
 task and the desired results.
 Since computational time is usually an important restriction, simpler and
 faster methods may be preferable.
\end_layout

\begin_layout Standard
Beside the convenience of a literature overview as presented here, it is
 very important to develop a feeling for the properties, advantages and
 drawbacks of the respective methods.
 Moreover, the recommendations of experts regarding the interpretation of
 the solutions and the feedback from everyday network operation are an essential
 input for establishing high-quality optimization methods.
\end_layout

\begin_layout Standard
Additionally, as noted for some of the cited works, hybrid methods, i.e.,
 approaches that combine different optimization and/or search techniques,
 usually give competitive solutions to complex optimization problems.
 Therefore, a simple optimization algorithm can quickly find a subset of
 reasonable solutions, whereas a more complex method could be applied afterwards
, to refine the search.
 Sometimes it may also be useful to apply a local search method at the end
 to find better solutions in the proximity of a current one.
\end_layout

\begin_layout Chapter
Principles of GPU programming 
\begin_inset CommandInset label
LatexCommand label
name "chap:02-Principles_of_GPU_programming"

\end_inset


\end_layout

\begin_layout Standard
During the past few years, the computing industry has been delivering extra
 processing power in the form of parallel computing, i.e., more cores instead
 of higher-frequency rates.
 Concurrently to this situation, new hardware architectures have appeared.
 Among them is the programmable Graphics Processing Unit (GPU
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "GPU"
description "Graphics processing unit."

\end_inset

), the computing capacity of which is already showing a faster progress
 compared to CPUs.
 The peak performance of the latest GPU is several times greater than the
 latest CPU, but even more important is the trend
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Cruz-How_to_obtain_efficient_GPU_kernels:2011"

\end_inset

.
\end_layout

\begin_layout Standard
The GPU market was almost exclusively driven by the games industry.
 This fact makes this commodity hardware cheaper than other alternatives
 for High-Performance Computing (HPC
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "HPC"
description "High-performance computing."

\end_inset

), e.g., the classic ‘mainframe’ servers.
 Moreover, the performance-per-watt of GPUs is an extra benefit over their
 raw performance
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Cruz-How_to_obtain_efficient_GPU_kernels:2011"

\end_inset

.
\end_layout

\begin_layout Standard
In February 2007, the first real opportunity for using GPUs for general
 programming and scientific computing came about with the release of the
 Compute Unified Device Architecture
\begin_inset space ~
\end_inset

(CUDA
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "CUDA"
description "Compute unified device architecture."

\end_inset

).
\end_layout

\begin_layout Standard
In the following, the focus on the CUDA architecture.
 In particular, similar hardware produced by other vendors, e.g., AMD and
 Intel, as well as other programming frameworks like OpenCL, are based on
 the same technology paradigm of massively-parallel processors.
 For this reason, the principles presented in this section can be applied
 to current GPU technologies, in a vendor-independent manner.
\end_layout

\begin_layout Section
CUDA
\end_layout

\begin_layout Standard
A GPU is effectively a large set of processor cores with the ability to
 directly address into a global memory.
 This makes it easier for developers to implement data-parallel kernels.
 The CUDA programming model 
\begin_inset CommandInset citation
LatexCommand cite
key "CUDA"

\end_inset

 was created for developing applications for the GPU platform.
 A system within this model consists of a host, i.e., a traditional CPU, and
 one or more compute devices that are massively data-parallel coprocessors,
 i.e., a GPU.
 The host code transfers data to and from the global memory of the GPU using
 CUDA-function calls.
 Each processor of a CUDA device supports the Single-Program Multiple-Data
\begin_inset space ~
\end_inset

(SPMD
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "SPMD"
description "Single-program multiple-data."

\end_inset

) model
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Atallah-Algorithms_and_theory_of_computation:2002"

\end_inset

, in which all concurrent threads are based on the same code, although they
 may not follow exactly the same path of execution.
\end_layout

\begin_layout Standard
A CUDA program consists of multiple parts that are executed on either the
 CPU or the GPU.
 For this reason, the CUDA programming model may be viewed as an environment
 to isolate program parts that are rich in data parallelism and thus should
 be executed on the GPU.
 The parallel parts of a CUDA program are implemented as kernels, i.e., functions
 written in the C language that describe the work of a single thread of
 execution.
 Several restrictions apply on kernel functions: there must be no recursion,
 no static variable declarations, and a non-variable number of arguments
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Ryoo-Optimization_principles_of_a_GPU_using_CUDA:2008"

\end_inset

.
 At run time, the kernel invocation is typically done on thousands of threads,
 which are organized within developer-defined groups called thread blocks.
 The threads can share data and synchronize their execution only within
 the block they belong to.
 Thread blocks are, in turn, organized in a higher-hierarchy level called
 grid.
 All threads within a given grid execute the same kernel function.
 During execution, continous sections of threads within a block are grouped
 into warps of 32 parallel threads, which represent the multi-threading
 scheduling unit
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Ryoo-Optimization_principles_of_a_GPU_using_CUDA:2008"

\end_inset

.
 A Streaming Multiprocessor (SM
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "SM"
description "Streaming multiprocessor."

\end_inset

) executes one instruction at a time for all the 32 threads in the warp.
 Consequently, if a thread block is not evenly divisible by the warp size,
 any remaining thread slots are wasted.
 Another undesirable situation appears when threads in a warp take different
 control paths, since the execution performance of the entire warp is reduced.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/GPU_architecture.eps
	width 40text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A simplified diagram of the architecture of a modern GPU.
 Adapted from
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Ryoo-Optimization_principles_of_a_GPU_using_CUDA:2008"

\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "fig:02-GPU_architecture"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The architecture of a typical GPU is depicted in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:02-GPU_architecture"

\end_inset

.
 It consists of 
\begin_inset Formula $n$
\end_inset

 SMs, each containing 
\begin_inset Formula $m$
\end_inset

 Streaming Processors (SPs
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "SP"
description "Streaming processor."

\end_inset

).
 Each SP executes a single instruction of a thread in a Single-Instruction,
 Multiple-Thread (SIMT
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "SIMT"
description "Single instruction multiple thread."

\end_inset

) manner
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Cruz-How_to_obtain_efficient_GPU_kernels:2011"

\end_inset

.
 The registers of each SM are dynamically partitioned among the threads
 running on it.
 
\end_layout

\begin_layout Standard
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:02-GPU_memory_properties"

\end_inset

 lists the different types of memory on a GPU, along with some of their
 properties.
 Specifically, the location of the memory, its hit-latency in terms of clock
 cycles, whether it is read-only or not, and the program scope it may be
 accessed from.
 Due to the different memory system a GPU has, the actual throughput an
 application can achieve depends on issues related to the access to memory,
 in particular the slow accesses to global memory from the GPU chip, and
 the use of shared memory in the SPs to mitigate the high-latency effects
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Cruz-How_to_obtain_efficient_GPU_kernels:2011"

\end_inset

.
 Since variables in the source code can be declared to reside in global,
 shared, local, or constant memory, a programmer has the means to organize
 the code in such a way that the application throughput can be maximized.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Properties of different memory types on a GeForge 8800 GPU.
 Adapted from
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Ryoo-Optimization_principles_of_a_GPU_using_CUDA:2008"

\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "tab:02-GPU_memory_properties"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomspace="default">
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Memory
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Location
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Latency
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Read-only
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Program scope
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Global
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
off-chip
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
200-300 cycles
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
global
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Texture
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
on-chip cache
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
~100 cycles
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
global
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Shared
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
on-chip
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
~register
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
function
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Register
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
on-chip
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
~1 cycle
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
function
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Clearly, there are hard limits to the memories, threads, and total bandwidth
 available to an application running on a GPU.
 Managing these limits is critical when optimizing applications, but applying
 strategies for avoiding one limit can easily cause other limits to be hit.
 Additionally, managing the behavior of threads so that those in the same
 warp follow the same control paths and load contiguous values from global
 memory can improve the execution performance
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Ryoo-Optimization_principles_of_a_GPU_using_CUDA:2008"

\end_inset

.
\end_layout

\begin_layout Standard
A detailed discussion of the CUDA programming model can be found in
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Farber-CUDA_application_design_and_development:2011"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
>>> reciclar esta parte de texto en algun otro lado
\end_layout

\begin_layout Plain Layout
\noindent
There is a constant growing demand for hardware resources, longer-processing
 times and more memory to follow the evolution of 3G radio networks 
\begin_inset CommandInset citation
LatexCommand cite
key "maple2004parallel,crainic2006tackling,soldani2007autonomic"

\end_inset

.
 Fortunately, high-performance computer systems are increasingly accessible;
 something made possible because of the emergence of computer clusters and
 commodity hardware, capable of true parallel processing, e.g.
 multi-core CPUs 
\begin_inset CommandInset citation
LatexCommand cite
key "gorder2007multicore"

\end_inset

 and GPUs 
\begin_inset CommandInset citation
LatexCommand cite
key "wen2011gpu"

\end_inset

.
 Moreover, the highly parallel structure present on GPUs makes them more
 effective than CPUs for execution of algorithms where large blocks of data
 need to be processed in parallel.
 Commodity GPUs have evolved from being a graphic accelerator into a general-pur
pose processor.
 They can achieve higher performance at lower power consumption and lower
 costs when compared to conventional CPUs.
 Additionally, the implementation of the framework will benefit from valuable
 advances in computer science and High Performance Computing (HPC), in order
 to perform faster and more reliable simulations 
\begin_inset CommandInset citation
LatexCommand cite
key "gorder2007multicore,wen2011gpu"

\end_inset

.
\end_layout

\begin_layout Plain Layout
<<<
\end_layout

\end_inset


\end_layout

\begin_layout Section
OpenCL 
\begin_inset CommandInset label
LatexCommand label
name "sub:02-OpenCL"

\end_inset


\end_layout

\begin_layout Standard
The Open computing language (OpenCL)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Stone_OpenCL.A.parallel.programming.standard:2010"

\end_inset

 is an open parallel computing API designed to enable GPUs and other co-processo
rs to work together with the CPU, providing additional computing power.
 As a standard, OpenCL 1.0 was released in 2008, by The Khronos Group, an
 independent standards consortium
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Munshi_The.OpenCL.specification:2009"

\end_inset

.
\end_layout

\begin_layout Standard
The main advantage of OpenCL over CUDA relies on the fact that its source
 code can be compiled to run on a variety of hardware, including multicore
 CPUs and GPUs from different vendors.
 This provides a complete framework that is capable of exploiting the parallel
 features of different hardware without the need of changing the implementation.
 Moreover, being an open standard, its users are not tight to the decision
 of only one vendor.
 As it was mentioned before, the details described in the previous sections
 may be equally applied on CUDA and OpenCL.
\end_layout

\begin_layout Standard
One unfortunate consequence of the vendor variety is that CUDA and OpenCL
 have each introduced its own naming conventions.
 For the sake of consistency, in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:02-CUDA_OpenCL_translation"

\end_inset

, a short 
\begin_inset Quotes eld
\end_inset

translation dictionary
\begin_inset Quotes erd
\end_inset

 between both platforms is presented.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Naming-convention translation between OpenCL and CUDA.
 Adapted from
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Kloeckner_CUDA.OpenCL.dictionary:2011"

\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "tab:02-CUDA_OpenCL_translation"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="2">
<features tabularvalignment="middle">
<column alignment="right" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomspace="default">
<cell alignment="right" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
OpenCL
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
CUDA
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Grid
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Grid
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Work group
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Block
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Work item
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Thread
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__kernel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__global__
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__global
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__device__
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__local
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__shared__
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__private
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__local__
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
image
\emph on
n
\emph default
d_t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
texture<type,
\emph on
n
\emph default
,...>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
barrier(L|M|F)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__syncthreads( )
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
get_local_id(0|1|2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
threadIdx.x|y|z
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
get_group_id(0|1|2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
blockIdx.x|y|z
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
get_global_id(0|1|2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
(not implemented)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the remaining of this thesis, the naming convention introduced by the
 CUDA platform is used.
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
This chapter gave an overview of the basic concepts, the potential and the
 limitations of the GPUs when used as parallel procesors for general programming.
 In particular, emphasis has been given to the details that differenciate
 this platform from the traditional serial architecture on CPUs.
 In this sense, it is important to recognize which applications can benefit
 from using a GPU and which not, also taking into consideration the effort
 required at the implementation time.
\end_layout

\end_body
\end_document
