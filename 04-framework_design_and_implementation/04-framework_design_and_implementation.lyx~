#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass MPSthesis
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 0
\use_mathdots 0
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
A parallel framework for radio-network planning and optimization 
\begin_inset CommandInset label
LatexCommand label
name "chap:04-Framework-design-and-implementation"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% First paragraph has no indentation.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this chapter, a parallel framework for radio-coverage simulation is presented.
 The objective of the framework is to provide an environment for the radio-cover
age prediction of large radio networks.
 Due to its high performance, the framework also enables the evaluation
 of more complex optimization problems for radio networks.
 
\end_layout

\begin_layout Standard
The framework is implemented as a module of a geographical information system,
 since the prediction calculation employs digital elevation models and land-usag
e data.
 Following a master-worker parallel paradigm over a message-passing communicatio
n model proved to be a bottleneck for the performance of the parallel module.
 A new approach, that overcomes this performance constraint, is introduced
 in this chapter.
 The efficiency improvement is based on overlapping process execution and
 communication.
 This minimizes the idle time of the worker processes and thus improves
 the overall efficiency of the system.
 To this end, the intermediate calculation results are saved into an external
 database (DB
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "DB"
description "Database system."

\end_inset

) instead of sending them back to the master process.
 This approach is implemented as part of a parallel radio-prediction tool
 (PRATO
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "PRATO"
description "Parallel radio-prediction tool."

\end_inset

) for the open-source Geographic Resources Analysis Support System (GRASS
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "GRASS"
description "Geographic Resources Analysis Support System."

\end_inset

)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Neteler_Open_source_GIS_a_GRASS_GIS_approach"

\end_inset

.
 An extended analysis of the experimental results is provided, which are
 based on real data from an LTE network currently deployed in Slovenia.
 Based on these experiments, which were performed on a computer cluster,
 the new technique exhibits better scalability than the traditional master-worke
r approach.
 Some real-world data sets are presented, the coverage predictions of which
 are calculated in a shorter time while saturating the hardware utilization.
\end_layout

\begin_layout Standard
The content of this chapter extends the research work published by the author
 in
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Benedicic-A_GRASS_GIS_parallel_module_for_radio_propagation_predictions:2013"

\end_inset

.
 The rest of this chapter is organized as follows.
 Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:04-Motivation"

\end_inset

 describes the motivation behind the presented research, followed by an
 overview of the relevant publications in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:04-Related_work"

\end_inset

, describing how they relate to this work.
 Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:04-Radio_coverage_prediction_for_mobile_networks"

\end_inset

 gives a description of the radio-coverage prediction problem, including
 the radio-propagation model.
 Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:04-Design_and_implementation"

\end_inset

 concentrates on the design and implementation of the radio-propagation
 tool, for both the serial and parallel versions.
 Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:04-Simulations"

\end_inset

 discusses the experimental results and their analysis.
\end_layout

\begin_layout Section
Motivation 
\begin_inset CommandInset label
LatexCommand label
name "sec:04-Motivation"

\end_inset


\end_layout

\begin_layout Standard
Although Gordon Moore's well-known and often cited prediction still holds
 
\begin_inset CommandInset citation
LatexCommand citep
key "Moore_Cramming_more_components_onto_integrated_circuits:1998"

\end_inset

, the fact is that for the past few years, CPU speeds have hardly been improving.
 Instead, the number of cores within a single CPU is increasing.
 This situation poses a challenge for software development in general and
 research in particular: a hardware upgrade will, most of the time, fail
 to double the serial-execution speed of its predecessor.
 However, since this commodity hardware is present in practically all modern
 desktop computers, it creates an opportunity for the parallel exploitation
 of these computing resources in order to enhance the performance of complex
 algorithms over large data sets.
 The challenge is thus to deliver the computing power of multi-core systems
 in order to tackle a computationally time-consuming problem, the completion
 of which is unfeasible using traditional serial approaches.
 Indeed, a performance improvement opens new possibilities regarding the
 data sizes and accuracy a model may handle.
\end_layout

\begin_layout Standard
A traditional approach, when dealing with computationally expensive problem
 solving, is to simplify the models, thus reducing the time needed for their
 calculation.
 Clearly, this method increases the introduced error level, which is not
 an option for a certain group of simulations, e.g., those dealing with disaster-c
ontingency planning and decision support
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Huang_Using_adaptively_coupled_models_and_high_performance_computing_for_enabling_the_computability_of_dust_storm_forecasting:2012,Yin_A_framework_for_integrating_GIS_and_parallel_computing_for_spatial_control_problems_a_case_study_of_wildfire_dontrol:2012"

\end_inset

.
 The conducted simulations during the planning phase of a radio network
 also belong to this group.
 The simulation results are the basis for the decision making prior to physicall
y installing the BSs and antennas that will cover a certain geographical
 area.
 A larger deviation of these results increases the probability of making
 the wrong decisions at installation time, which may considerably increase
 the costs or even cause mobile-network operators to incur losses.
\end_layout

\begin_layout Standard
Various researchers have successfully deployed HPC systems and techniques
 to solve different problems dealing with spatial data
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Akhter_Porting_GRASS_raster_module_to_distributed_computing:2007,Armstrong_Using_a_computational_grid_for_geographic_information_analysis:2005,Guan_A_parallel_computing_approach_to_fast_geostatistical_areal_interpolation:2011,Huang_Using_adaptively_coupled_models_and_high_performance_computing_for_enabling_the_computability_of_dust_storm_forecasting:2012,Li_Parallel_cellular_automata_for_large_scale_urban_simulation_using_load_balancing_techniques:2010,Osterman_CUDA_on_GRASS:2012,Tabik-High_performance_three_horizon_composition_algorithm_for_large_scale_terrains:2011,Tabik-Optimal_tilt_and_orientation_maps_a_multi_algorithm_approach_for_heterogeneous_multicore_GPU_systems:2013,Tabik_Simultaneous_computation_of_total_viewshed_on_large_high_resolution_grids:2012,Widener_Developing_a_parallel_computational_implementation_of_AMOEBA:2012,Yin_A_framework_for_integrating_GIS_and_parallel_computing_for_spatial_control_problems_a_case_study_of_wildfire_dontrol:2012"

\end_inset

.
 Their work confirms that a parallel paradigm such as master-worker, and
 techniques like work pool (or task farming) and spatial-block partitioning
 are applicable when dealing with parallel implementations over large spatial
 data sets.
 However, it is well known that parallel programming and HPC often call
 for area experts in order to integrate them into a given environment
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Clematis_High_performance_computing_with_geographical_data:2003"

\end_inset

.
 Moreover, the wide range of options currently available creates even more
 barriers for general users wanting to benefit from HPC.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
In this chapter, a high-performance, radio-planning framework for GSM
\begin_inset space ~
\end_inset

(2G), UMTS
\begin_inset space ~
\end_inset

(3G) and LTE
\begin_inset space ~
\end_inset

(4G) networks is presented.
 Using a snapshot-based approach (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:06-Radio_network_model"

\end_inset

), the performance estimation of a radio network is divided into two parts,
 i.e., the coverage prediction and the performance analysis.
 During the coverage prediction, which is the subject of this chapter, path-loss
 matrixes are created based on radio-propagation models, a network configuration
, and digital maps of the target geographical area.
 Hence, in addition to a reliable radio-propagation model, also the resolution
 of the digital map should be high enough.
\end_layout

\begin_layout Standard
During the performance-analysis part, which is discussed in the following
 chapters, the predicted path losses are used for analyzing different phenomena,
 e.g., service availability and SHO performance.
 Therefore, the largest influence on the result performance of the framework
 comes from the calculated coverage predictions
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Coinchon-The_impact_of_radio_propagation_predictions:2020"

\end_inset

.
\end_layout

\begin_layout Standard
The framework is also suitable as a support tool for maintenance activities
 related to network troubleshooting in general and optimization in particular.
 Specifically, automatic radio-coverage optimization requires the evaluation
 of millions of radio-propagation predictions in order to find a good solution
 set.
 This is often unfeasible using other serial implementations of academic
 or commercial tools
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Ozimek_Open.source.radio.coverage.prediction:2010,Mehlfuhrer_The_Vienna_LTE_Simulators_enabling_reproducibility_in_wireless_communications_research:2011,Piro_Simulating_LTE_cellular_systems_an_open_source_framework:2011"

\end_inset

.
\end_layout

\begin_layout Standard
As a reference implementation, the publicly available radio-coverage prediction
 tool, presented in
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Ozimek_Open.source.radio.coverage.prediction:2010"

\end_inset

, was used.
 The authors developed a modular radio-coverage tool that performs separate
 calculations for radio-signal path loss and antenna-radiation patterns,
 also taking into account different configuration parameters, such as antenna
 tilting, azimuth and height.
 The output result, saved as a raster map, is the maximum signal level over
 the target area, in which each point represents the received signal from
 the best-serving transmitter (or cell).
 This work implements some well-known radio-propagation models, e.g., Okumura-Hata
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citet
key "Hata_Empirical_formula_for_propagation_loss_in_land_mobile_radio_services:1980"

\end_inset

, the description of which is latter presented in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:04-Radio_propagation_model"

\end_inset

.
 Regarding the accuracy of the predicted values, the authors reported comparable
 results to those of an industrial tool
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Ozimek_Open.source.radio.coverage.prediction:2010"

\end_inset

.
 To ensure that the presented implementation is completely compliant with
 this reference, a comparison test was designed, that consists of running
 both tools with the same set of input parameters.
 The test results from PRATO and the reference implementation were identical
 in all the tested cases.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
By improving the speed performance and data-set sizes a well-known approach
 may handle, we are constantly opening new possibilities for research of
 new models and implementations of enhanced analytical methods.
 Geographic information sciences are no exception to this rule, especially
 because they are a traditional rich source of large data sets 
\begin_inset CommandInset citation
LatexCommand citep
key "Clematis_High_performance_computing_with_geographical_data:2003,Hawick_Distributed_frameworks_and_parallel_algorithms_for_processing_large_scala_geographic_data:2003"

\end_inset

.
 During recent years, many authors have presented studies which show the
 benefits of high-performance computing (HPC) and parallel programming in
 the area of geographical information analysis and decision support.
 It comes to no surprise that the tool of choice on which most of these
 works have focused is geographic information systems (GIS).
 Their importance is further increased as they are generally the gathering
 point of interdisciplinary research, which employs geographical data for
 different kinds of problem-solving 
\begin_inset CommandInset citation
LatexCommand citep
key "Ozimek_Open.source.radio.coverage.prediction:2010,Osterman_CUDA_on_GRASS:2012,Xiao_A_unified_conceptual_framework_for_geographical_optimization_using_evolutionary_algorithms:2008,Yin_A_framework_for_integrating_GIS_and_parallel_computing_for_spatial_control_problems_a_case_study_of_wildfire_dontrol:2012"

\end_inset

, analysis and decision support 
\begin_inset CommandInset citation
LatexCommand citep
key "Densham_Spatial_decision_support_systems:1991,Jankowski_Spatial_group_choice_a_SDDS_tool_for_collaborative_spatial_decision_making:1997,Simao_Web_based_GIS_for_collaborative_planning_and_public_participation_an_application_to_the_strategic_planning_of_wind_farm_sites:2009"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Our work aims at shedding some light over this inherent complexity, by proposing
 some key patterns, and combining them with a relational database, so that
 any group of desktop computers can be easily transformed in a computer
 cluster and its computing capacity exploited.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Related work 
\begin_inset CommandInset label
LatexCommand label
name "sec:04-Related_work"

\end_inset


\end_layout

\begin_layout Standard
There are few examples of radio-network simulators in the literature
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Ozimek_Open.source.radio.coverage.prediction:2010,Mehlfuhrer_The_Vienna_LTE_Simulators_enabling_reproducibility_in_wireless_communications_research:2011,Pillekeit-A_hybrid_simulation_framework_for_the_evaluation_of_common_RRM:2012,Piro_Simulating_LTE_cellular_systems_an_open_source_framework:2011,Sanchez_Performance_evaluation_of_OFDMA_wireless_systems_using_WM_SIM:2006,Yeung-Detailed_OFDM_modeling_in_network_simulation:2004"

\end_inset

.
 Most of these tools were developed for academic research, thus not targeting
 industrial-sized environments.
 
\end_layout

\begin_layout Standard
A Matlab-based LTE simulator was proposed in
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Mehlfuhrer_The_Vienna_LTE_Simulators_enabling_reproducibility_in_wireless_communications_research:2011"

\end_inset

.
 It implements a standard LTE downlink physical layer, including Adaptive
 Modulation and Coding (AMC
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "AMC"
description "Adaptive modulation and coding."

\end_inset

), multiple users, Multiple Input Multiple Output (MIMO
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "MIMO"
description "Multiple input multiple output."

\end_inset

) transmission and scheduler.
 Despite being open source and freely available, the fact of being implemented
 in Matlab makes it restrictive in terms of tackling big problem instances
 of real networks.
\end_layout

\begin_layout Standard
A promising tool from the performance point of view was presented in 
\begin_inset CommandInset citation
LatexCommand citep
key "Piro_Simulating_LTE_cellular_systems_an_open_source_framework:2011"

\end_inset

, where the authors implemented a full-stack LTE system in C++.
 Although the tool has no graphical capabilities for displaying the simulation
 progress or outcome, they might be included, since the source code is available.
 In our opinion, the main drawback of this tool is the lack of documentation,
 which makes it very difficult to continue extending this work without the
 direct help of some of the original authors.
\end_layout

\begin_layout Standard
As an extension to the well-known NS-2 network simulator, Filiposka and
 Trajanov 
\begin_inset CommandInset citation
LatexCommand citep
key "Filiposka_Terrain_aware_three_dimensional_radio_propagation_model_extension_for_NS2:2011"

\end_inset

 introduced a module for radio-propagation predictions, which takes the
 terrain profile into account.
 In this case, the authors focus on the relief, leaving out signal loss
 due to land-usage, which is an important factor when targeting realistic
 radio-propagation scenarios.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
The task-parallelization problem within the GRASS environment was addressed
 by several authors in a variety of studies.
 For example, in
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Campos_Parallel_modelling_in_GIS:2012"

\end_inset

, the authors presented a collection of GRASS modules for a watershed analysis.
 Their work concentrates on different ways of slicing raster maps to take
 advantage of a Message Passing Interface (MPI
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "MPI"
description "Message passing interface."

\end_inset

) implementation.
\end_layout

\begin_layout Standard
In the field of HPC, the authors in
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Akhter_Porting_GRASS_raster_module_to_distributed_computing:2007"

\end_inset

 presented MPI and Ninf-G implementation examples of a GRASS raster module,
 that processes vegetation indexes from satellite images.
 The authors acknowledge a limitation in the performance of their MPI implementa
tion for big processing jobs.
 The restriction appears due to the computing nodes being fixed to a specific
 spatial range, since the input data are equally distributed among worker
 processes, creating an obstacle for load balancing in heterogeneous environment
s.
\end_layout

\begin_layout Standard
Using a master-worker technique, the work presented in
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Huang-Explorations_of_the_implementation_of_a_parallel_IDW_algorithm_in_a_Linux_cluster:2011"

\end_inset

 abstracts the GRASS data types into its own 
\emph on
struct
\emph default
 and MPI data types, thus not requiring the GRASS in the worker nodes.
 The data are evenly distributed by rows among the workers, with each one
 receiving an exclusive column extent to work on.
 Their test cluster contained heterogeneous hardware configurations.
 The authors noted that data-set size is bounded by the amount of memory
 on each of the nodes, since they allocate the memory for the whole map
 as part of the set-up stage, before starting the calculation.
 Regarding the data sets during the simulations, the largest one contained
 3,265,110 points.
 They concluded that the data-set size should be large enough for the communicat
ion overhead to be hidden by the calculation time, so that the parallelization
 pays off.
\end_layout

\begin_layout Standard
In
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Tabik-High_performance_three_horizon_composition_algorithm_for_large_scale_terrains:2011"

\end_inset

, the authors employed a master-worker approach, using one worker process
 per worker node.
 The complete exploitation of the computing resources of a single computing
 node is achieved with OpenMP.
 The experimental environment featured one host.
 The horizon-composition algorithm presents no calculation dependency among
 the spatial blocks.
 Consequently, the digital elevation model (DEM
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "DEM"
description "Digital elevation model."

\end_inset

) was divided into separate blocks to be independently calculated by each
 worker process.
 The authors presented an improved algorithm that can also be used to accelerate
 other applications like visibility maps.
 The tasks are dynamically assigned to idle processes using a task-farming
 paradigm over the MPI.
 
\end_layout

\begin_layout Standard
Similar to
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Tabik-High_performance_three_horizon_composition_algorithm_for_large_scale_terrains:2011"

\end_inset

, in
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Tabik-Optimal_tilt_and_orientation_maps_a_multi_algorithm_approach_for_heterogeneous_multicore_GPU_systems:2013"

\end_inset

 there was no calculation dependency among the spatial blocks.
 The experimental evaluation was made over multiple cores of one CPU and
 a GPU, and a master-worker setup was used for process communication.
\end_layout

\begin_layout Standard
In
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Yin_A_framework_for_integrating_GIS_and_parallel_computing_for_spatial_control_problems_a_case_study_of_wildfire_dontrol:2012"

\end_inset

, the authors presented a parallel framework for GIS integration.
 Based on the principle of spatial dependency, they lowered the calculation-proc
essing time using a knowledge database, delivering the heavy calculation
 load to the parallel back-end if a specific problem instance is not found
 in the database.
 There was an additional effort to achieve the presented goals, since the
 implementation of a fully functional GIS (or 
\begin_inset Quotes eld
\end_inset

thick GIS
\begin_inset Quotes erd
\end_inset

 as the authors call it) was required on both the desktop client and in
 the parallel environment.
\end_layout

\begin_layout Standard
An agent-based approach for simulating spatial interactions was presented
 in
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Gong_Parallel_agent_based_simulation_of_individual_level_spatial_interactions_within_a_multicore_computing_environment:2012"

\end_inset

.
 This technique decomposes the entire landscape into equally-sized regions,
 i.e., a spatial-block division as in 
\begin_inset CommandInset citation
LatexCommand citep
key "Tabik-High_performance_three_horizon_composition_algorithm_for_large_scale_terrains:2011"

\end_inset

, which are in turn processed by a different core of a multi-core CPU.
 This work used multi-core CPUs instead of a computing cluster.
\end_layout

\begin_layout Standard
Some years ago, grid computing received a lot of attention from the research
 community.
 It appeared to be a good alternative for accessing the extra computational
 power needed for the spatial analysis of large data sets
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Armstrong_Using_a_computational_grid_for_geographic_information_analysis:2005,Vouk_Cloud_computing_issues_research_and_implementations:2008,Wang_A_cybergis_framework_for_the_synthesis_of_cyberinfrastructure_GIS_and_spatial_analysis:2010"

\end_inset

.
 However, several obstacles are still preventing this technology from being
 widely used.
 In particular, its adoption requires not only hardware and software compromises
 with respect to the involved parts, but also a behavioral change at the
 human level
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Armstrong_Using_a_computational_grid_for_geographic_information_analysis:2005"

\end_inset

.
\end_layout

\begin_layout Section
Radio-coverage prediction for mobile networks 
\begin_inset CommandInset label
LatexCommand label
name "sec:04-Radio_coverage_prediction_for_mobile_networks"

\end_inset


\end_layout

\begin_layout Subsection
Background
\end_layout

\begin_layout Standard
As it was mentioned in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:02-Principles_of_mobile_radio_networks"

\end_inset

, radio communications in a mobile network take place between a BS (or fixed
 transmitter) and a number of UEs (or mobile receivers).
 The effects of signal propagation limit the performance of a mobile-radio
 system.
 For this reason, the characterization and modeling of radio propagation
 is considered a fundamental aspect in radio-network planning 
\begin_inset CommandInset citation
LatexCommand citep
key "Ahmad:Studying_different_propagation_models_for_LTE_system:2012"

\end_inset

.
 Consequently, understanding the mathematical modeling of a frequency channel
 is necessary to accurately predict the system performance and to provide
 a mechanism to analyze the effects caused by signal propagation 
\begin_inset CommandInset citation
LatexCommand cite
key "Parsons-The_mobile_radio_propagation_channel:2000"

\end_inset

.
\end_layout

\begin_layout Standard
The coverage planning of radio networks is a key problem that all mobile
 operators have to deal with.
 Moreover, it has proven to be a fundamental issue, not only in LTE networks,
 but also in other standards for mobile communications
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Saleh_On_the_coveraga_extension_in_LTE_networks:2010,Shabbir_Comparison_of_radio_propagation_models:2011,Siomina:Minimum.pilot.power.for.service.coverage,Valcarce_Applying.FDTD.to.the.coverage.prediction.of.WiMAX:2009"

\end_inset

.
 One of the primary objectives of mobile-network planning is to efficiently
 use the allocated frequency band to ensure that some geographical area
 of interest can be satisfactorily reached with the BSs of the network.
 To this end, radio-coverage prediction tools are of great importance, as
 they allow network engineers to test different network configurations before
 physically implementing the changes.
 Radio-coverage prediction is a complex task, mainly due to the several
 combinations of hardware and configuration parameters that have to be analyzed
 in the context of different environments.
 The complexity of the problem means that radio-coverage predictions are
 computationally-intensive and time-consuming, hence the importance of using
 fast and accurate tools (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:04-Computational_complexity"

\end_inset

 for a complexity analysis of the algorithm).
 Additionally, since the number of deployed transmitters keeps growing with
 the adoption of modern standards
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Saleh_On_the_coveraga_extension_in_LTE_networks:2010"

\end_inset

, there is a clear need for a radio-propagation tool that is able to cope
 with larger work loads in a feasible amount of time (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:04-Computational_complexity"

\end_inset

 for the running time of the serial version).
\end_layout

\begin_layout Subsection
Radio-propagation model 
\begin_inset CommandInset label
LatexCommand label
name "sub:04-Radio_propagation_model"

\end_inset


\end_layout

\begin_layout Standard
PRATO uses a modified version of the well-known Okumura-Hata model for radio-pro
pagation predictions
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Hata_Empirical_formula_for_propagation_loss_in_land_mobile_radio_services:1980"

\end_inset

.
 Other accurate methods exist, like the ones based on ray tracing
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Corre_Three_dimensional_urban_EM_wave_propagation_model_for_radio_network_planning_and_optimization_over_large_areas:2009,Vilhar-Efficient_open_source_ray_tracing_methods_for_rural_environment:efficient"

\end_inset

.
 However, these methods are more sensible to deviations in input data, like
 DEMs and buildings, and are still inefficient in terms of the computational
 effort required to achieve satisfying results.
 Empirical methods for radio-propagation predictions, like Okumura-Hata,
 give acceptable results within a feasible amount of time.
 For this reason, they have become the industry standard for non-deterministic
 signal-propagation calculations
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Begovic_Applicability_evaluation_of_Okumura_Ericsson_and_Winner_propagation_models_for_coverage_planning:2012,Cichon_Propagation.prediction.models:1995,Hata-Empirical_formula_for_propagation_loss_in_land_mobile_radio_services:1980,Shabbir_Comparison_of_radio_propagation_models:2011,Song_Evolved_cellular_network_planning_and_optimization_for_UMTS_and_LTE:2010"

\end_inset

.
\end_layout

\begin_layout Standard
The Okumura-Hata model has been largely studied and shown to be suitable
 for predicting the radio propagation in LTE networks
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Ahmad:Studying_different_propagation_models_for_LTE_system:2012,Shabbir_Comparison_of_radio_propagation_models:2011"

\end_inset

.
 In its primary form, the model distinguishes the distance from the receiver
 to the transmitter, the frequency used and the effective antenna height,
 i.e., the height of the antenna above the receiver's level.
 These variables are taken into account in order to calculate the path loss
 in open-area (OA
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "OA"
description "Open area."

\end_inset

) conditions.
 Additionally, for distinguishing non-line-of-sight (NLOS
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "NLOS"
description "Non line of sight."

\end_inset

) conditions, the terrain profile and Earth shape are added to the original
 formula.
 In this context, a NLOS situation appears when the first Fresnel zone is
 obscured by at least one obstacle.
 A Fresnel zone is defined as one of the concentric ellipsoids which define
 volumes in the radiation pattern of a circular aperture
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Xia-Radio_propagation_characteristics_for_line_of_sight_microcellular_and_personal_communications:1993"

\end_inset

.
\end_layout

\begin_layout Standard
As it was mentioned before, the path-loss evaluation employed here is based
 on the Okumura-Hata model.
 When in an OA environment, the path loss is described as in Equation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:04-Hata_OA"

\end_inset

):
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\mathrm{L}{}_{\mathrm{OA}}(d_{(x,y)},\vec{\beta}) & = & \beta_{0}+\beta_{1}\log(d_{(x,y)})+\beta_{2}\log(H_{\mathrm{A}})+\beta_{3}\log(d_{(x,y)})\log(H_{\mathrm{A}})-\nonumber \\
 &  & 3.2\left[\log(11.75\cdot H_{\mathrm{R}})\right]^{2}+44.49\log(F)-4.78\left[\log(F)\right]^{2},\label{eq:04-Hata_OA}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "S"
symbol "$\\mathrm{L}_{\\mathrm{OA}}$"
description "Path loss in an open-area environment."

\end_inset


\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "S"
symbol "$\\vec{\\beta}$"
description "Control-parameter vector of the path-loss model."

\end_inset


\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "S"
symbol "$d_{(x,y)}$"
description "Distance from the cell to the topography point with coordinates $(x,y)$."

\end_inset


\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "S"
symbol "$H_A$"
description "Antenna height above the receiver."

\end_inset


\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "S"
symbol "$H_R$"
description "Height of the receiver antenna above ground level."

\end_inset


\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "S"
symbol "$F$"
description "Transmission frequency."

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\vec{\beta}=(\beta_{0},\beta_{1},\beta_{2},\beta_{3})$
\end_inset

 is the vector containing the control parameters of the model, 
\begin_inset Formula $d_{(x,y)}$
\end_inset

 is the distance (in kilometers) from the transmitter to the topography
 point with coordinates 
\begin_inset Formula $(x,y)$
\end_inset

, 
\begin_inset Formula $H_{\mathrm{A}}$
\end_inset

 is the effective antenna height (in meters) of the transmitter, 
\begin_inset Formula $H_{\mathrm{R}}$
\end_inset

 is the antenna height (in meters) of the receiver, and 
\begin_inset Formula $F$
\end_inset

 is the frequency, expressed in MHz.
 In NLOS conditions, the additional path loss is calculated as in Equation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:04-Hata_NLOS"

\end_inset

):
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\mathrm{L}{}_{\mathrm{NLOS}}(d_{(x,y)})=\sqrt{\left[\alpha K(d_{(x,y)})\right]^{2}+E(d_{(x,y)})^{2}},\label{eq:04-Hata_NLOS}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "S"
symbol "$\\mathrm{L}_{\\mathrm{NLOS}}$"
description "Path loss in non-line-of-sigth conditions."

\end_inset


\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "S"
symbol "$\\alpha$"
description "Knife-edge diffraction control parameter."

\end_inset


\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "S"
symbol "$K(d_{(x,y)})$"
description "Knife-edge diffraction loss."

\end_inset


\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "S"
symbol "$E(d_{(x,y)})$"
description "Loss correction due to the Earth sphere."

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\alpha$
\end_inset

 is the knife-edge diffraction
\begin_inset Foot
status open

\begin_layout Plain Layout
\noindent
Knife-edge diffraction occurs when a portion of the incident radiation reaches
 a well-defined obstacle such as a mountain or the edge of a building.
\end_layout

\end_inset

 control parameter, the value of which is calculated based on the level
 of obstruction of a Fresnel zone, 
\begin_inset Formula $K(d_{(x,y)})$
\end_inset

 is the knife-edge diffraction loss (in
\begin_inset space ~
\end_inset

dB), and 
\begin_inset Formula $E(d_{(x,y)})$
\end_inset

 is the correction due to the Earth sphere (in
\begin_inset space ~
\end_inset

dB).
 All three values depend on the characteristics of the topography point
 with coordinates 
\begin_inset Formula $(x,y)$
\end_inset

.
\end_layout

\begin_layout Standard
In this work, as well as in
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Filiposka_Terrain_aware_three_dimensional_radio_propagation_model_extension_for_NS2:2011"

\end_inset

, the terrain profile is used for line-of-sight (LOS
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "LOS"
description "Line of sight."

\end_inset

) determination, i.e., an obstacle obstruction in the first Fresnel zone of
 the transmitter.
 In order to adequately predict signal-loss effects due to foliage, buildings
 and other fabricated structures, additional loss factors based on the land
 usage (clutter data), are included.
 This technique is adopted by several propagation models for radio networks
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Aarnaes-Tuning_of_empirical_radio_propagation_models_effect_of_location_accuracy:2004,Begovic_Applicability_evaluation_of_Okumura_Ericsson_and_Winner_propagation_models_for_coverage_planning:2012,Neskovic_Microcell_electric_field_strength_prediction_model:2010"

\end_inset

.
 Consequently, an extra term is introduced for signal loss due to clutter,
 thus defining the model-predicted path loss as:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\mathrm{L}(d_{(x,y)},\vec{\beta})=\mathrm{L}{}_{\mathrm{OA}}(d_{(x,y)},\vec{\beta})+\mathrm{L}_{\mathrm{NLOS}}(d_{(x,y)})+\mathrm{L}{}_{\mathrm{CLUT}}(d_{(x,y)}),\label{eq:04-Hata_pathloss}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "S"
symbol "$\\mathrm{L}(d_{(x,y)})$"
description "Path loss at the topography point with coordinates $(x,y)$."

\end_inset


\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "S"
symbol "$\\mathrm{L}_{\\mathrm{CLUT}}$"
description "Signal loss due to clutter."

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\mathrm{L}{}_{\mathrm{CLUT}}(d_{(x,y)})$
\end_inset

 represents the clutter loss at the topography point with coordinates 
\begin_inset Formula $(x,y)$
\end_inset

, expressed in dB.
\end_layout

\begin_layout Section
Design and implementation 
\begin_inset CommandInset label
LatexCommand label
name "sec:04-Design_and_implementation"

\end_inset


\end_layout

\begin_layout Subsection
Geographic Resources Analysis Support System
\end_layout

\begin_layout Standard
GRASS
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Neteler_Open_source_GIS_a_GRASS_GIS_approach"

\end_inset

, a free and open-source software project that implements a Geographical
 Information System (GIS
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "GIS"
description "Geographical information system."

\end_inset

), is used as the software environment for PRATO.
 This GIS software was originally developed at the US Army Construction
 Engineering Research Laboratories and is a full-featured system with a
 wide range of analytical, data-management, and visualization capabilities.
 Currently, the development of GRASS GIS is supported by a growing community
 of volunteer developers.
\end_layout

\begin_layout Standard
The use of GRASS GIS as an environment for PRATO presents many advantages.
 First, the current development of GRASS is primarily Linux-based.
 Since the field of HPC is dominated by Linux and UNIX systems, an environment
 with Linux support is critical for this work.
 Software licensing is another important consideration for choosing GRASS,
 since it is licensed under the GNU Public License 
\begin_inset CommandInset citation
LatexCommand citep
key "Stallman_GNU_License:1991"

\end_inset

 that imposes the availability of the source code.
 This allows to make potential modifications to the system, thus adapting
 it for the parallel computation environment.
 Moreover, GRASS provides a great deal of built-in functionality, capable
 of operating with raster and vector topological data that can be stored
 in an internal format or a DB.
\end_layout

\begin_layout Subsection
Multi-paradigm parallel programming
\end_layout

\begin_layout Standard
The implementation methodology adopted for PRATO follows a multi-paradigm,
 parallel programming approach in order to fully exploit the resources of
 each node in a computing cluster.
 This approach combines a master-worker paradigm with an external DB.
 To efficiently use a shared memory multi-processor on the worker side,
 and to effectively overlap the calculation and communication, PRATO uses
 POSIX threads
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Butenhof_Programming.with.POSIX.threads:1997"

\end_inset

.
\end_layout

\begin_layout Standard
To use the computing resources of a distributed memory system, such as a
 cluster of processors, PRATO uses the MPI
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Gropp_Using_MPI:1999"

\end_inset

.
 The MPI is a message-passing standard that defines the syntax and semantics
 designed to function on a wide variety of hardware.
 The MPI enables multiple processes, running on different processors of
 a computer cluster, to communicate with each other.
 It was designed for high performance on both massively parallel machines
 and on workstation clusters.
\end_layout

\begin_layout Standard
PRATO also supports the execution of the most computationally-intensive
 parts of the radio-propagation algorithm on a GPU.
 Moreover, the GPU hardware is used if it is available on the computing
 nodes that host the worker processes (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:04-GPU_worker_implementation"

\end_inset

 later in this chapter for a discussion about the GPU implementation).
\end_layout

\begin_layout Standard
In order to make the text clearer and to differentiate between the programming
 paradigms used from here on, a POSIX thread will be refered to simply as
 a `thread' and a MPI process as a `process'.
\end_layout

\begin_layout Subsection
Design of the serial version
\end_layout

\begin_layout Standard
This section describes the different functions contained in the serial version
 of PRATO, which is implemented as a GRASS module.
 Their connections and data flow are depicted in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Flow_diagram_serial_version"

\end_inset

, where the parallelograms of the flow diagram represent the input/output
 (I/O
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "I/O"
description "Input/output."

\end_inset

) operations.
 
\end_layout

\begin_layout Standard
The design follows a similar internal organization as the radio-planning
 tool presented in 
\begin_inset CommandInset citation
LatexCommand citep
key "Ozimek_Open.source.radio.coverage.prediction:2010"

\end_inset

, but with some important differences.
 Specifically, the design presented here employs a direct connection to
 an external database server for intermediate result saving, instead of
 the slow, built-in GRASS database drivers.
 To explicitly avoid tight coupling with a specific database vendor, the
 generated output is formatted in plain text, which is then forwarded to
 the DB.
 Any further processing is achieved by issuing a query over the database
 tables that contain the path-loss results for each of the processed transmitter
s.
\end_layout

\begin_layout Subsubsection
Input parameters
\end_layout

\begin_layout Standard
All input data are read in the first step (see 
\begin_inset Quotes eld
\end_inset

Read input data
\begin_inset Quotes erd
\end_inset

 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Flow_diagram_serial_version"

\end_inset

).
 Their formats differ based on the data they contain, i.e.:
\end_layout

\begin_layout Itemize
GRASS raster files are used for the DEM and clutter data, whereas
\end_layout

\begin_layout Itemize
a text file is used for the transmitter configurations and other service-depende
nt options.
\end_layout

\begin_layout Standard
Since the module accepts a considerable amount of input parameters, they
 are read from a text-based initialization (INI
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "INI"
description "Initialization file."

\end_inset

) file.
 This is far more practical than passing them as command-line parameters,
 which would make them error-prune and difficult to read.
 Besides, the INI file may contain configuration parameters for many transmitter
s.
 The user selects which one(s) to process at run-time by passing a command-line
 option.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/serial_implementation_flow_diagram.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Flow diagram of the serial version.
\emph default

\begin_inset CommandInset label
LatexCommand label
name "fig:04-Flow_diagram_serial_version"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Isotropic path-loss calculation
\begin_inset CommandInset label
LatexCommand label
name "sub:04-Isotrophic_pahloss_calculation"

\end_inset


\end_layout

\begin_layout Standard
This step starts by calculating which receiver points, 
\begin_inset Formula $r$
\end_inset

, are within the specified transmission radius (see 
\begin_inset Quotes eld
\end_inset


\emph on
transmission radius
\emph default

\begin_inset Quotes erd
\end_inset

 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Flow_diagram_serial_version"

\end_inset

).
 The transmission radius is defined around each transmitter in order to
 limit the radio-propagation calculation to a reasonable distance.
 For these points, the path loss for an isotropic source (or omni antenna)
 is estimated.
 This calculation is performed by applying the radio-propagation model,
 which was previously defined in Equation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:04-Hata_pathloss"

\end_inset

), to each of the points within the transmission radius around the transmitter
 (see 
\begin_inset Quotes eld
\end_inset

Calculate path loss
\begin_inset Quotes erd
\end_inset

 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Flow_diagram_serial_version"

\end_inset

).
\end_layout

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Raster_path_loss_example"

\end_inset

 shows an example of the isotropic path-loss calculation, only including
 the map area within the transmission radius.
 The color scale is given in dB, indicating the signal loss from the isotropic
 source of the transmitter, located at the center.
 Notice the hilly terrain is clearly distinguished due to LOS and NLOS condition
s from the signal source.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/isotrophic_calculation.eps
	lyxscale 30
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Example of a raster map, showing the result of a path-loss calculation from
 an isotropic antenna.
 The color scale is given in dB, indicating the path loss at a given point.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:04-Raster_path_loss_example"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Antenna diagram influence 
\begin_inset CommandInset label
LatexCommand label
name "sub:04-Antenna_diagram_influence"

\end_inset


\end_layout

\begin_layout Standard
This step considers the antenna radiation diagram of the current transmitter
 and its influence over the isotropic path-loss calculation (see 
\begin_inset Quotes eld
\end_inset

Calculate antenna influence
\begin_inset Quotes erd
\end_inset

 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Flow_diagram_serial_version"

\end_inset

).
 Working on the in-memory results generated by the previous step, the radiation
 diagram of the antenna is taken into account, including the beam direction,
 the electrical and the mechanical tilt.
 Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Raster_antenna_example"

\end_inset

 shows the map area within the transmission radius, where this calculation
 step was applied to the results from Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Raster_path_loss_example"

\end_inset

.
 Notice the distortion of the signal propagation that the antenna has introduced.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/antenna_calculation.eps
	lyxscale 30
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Example of a raster map, showing the influence of a directional antenna
 over the path-loss result depicted in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Raster_path_loss_example"

\end_inset

.
 The color scale is given in dB, indicating the path loss at a given point.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:04-Raster_antenna_example"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Transmitter path-loss prediction 
\begin_inset CommandInset label
LatexCommand label
name "sub:04-Transmitter_path_loss_prediction"

\end_inset


\end_layout

\begin_layout Standard
In this step, the path-loss prediction of the transmitter is saved in its
 own database table (see 
\begin_inset Quotes eld
\end_inset

Save transmitter path-loss to DB
\begin_inset Quotes erd
\end_inset

 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Flow_diagram_serial_version"

\end_inset

).
 This is accomplished by connecting the standard output of the GRASS module
 with the standard input of a database client.
 Naturally, the generated plain text should be understood by the DB itself.
\end_layout

\begin_layout Subsubsection
Coverage prediction 
\begin_inset CommandInset label
LatexCommand label
name "sub:04-Coverage_prediction"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/final_coverage.eps
	lyxscale 10
	width 65text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Example of a raster map, displaying the final coverage prediction of 136
 transmitters over a geographical area.
 The color scale is given in dBm, indicating the received-signal strength.
 Darker colors denote areas with a reduced signal due to the fading effect
 of the hilly terrain and clutter.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:04-Raster_prediction_example"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The final radio-coverage prediction, containing the aggregation of the partial
 path-loss results of the involved transmitters, is created in this step
 (see 
\begin_inset Quotes eld
\end_inset

Create final coverage prediction
\begin_inset Quotes erd
\end_inset

 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Flow_diagram_serial_version"

\end_inset

).
 The received signal strength from each of the transmitters is calculated
 as the difference between its transmit power and the path loss for the
 receiver's corresponding position.
 This is done by executing an SQL query over the tables containing the path-loss
 predictions of each of the processed transmitters.
 Finally, the output is generated using the GRASS built-in modules 
\begin_inset Formula $v.in.ascii$
\end_inset

 and 
\begin_inset Formula $v.to.rast$
\end_inset

, which create a raster map using the query results as the input.
 The resulting raster map contains the maximum received signal strength
 for each individual point, as shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Raster_prediction_example"

\end_inset

.
 In this case, the color scale is given in dBm, indicating the strongest
 received signal strength from the transmitters.
\end_layout

\begin_layout Subsection
Computational complexity 
\begin_inset CommandInset label
LatexCommand label
name "sub:04-Computational_complexity"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Pseudo-code of the radio-coverage prediction algorithm.
 The time complexity is given per line.
\begin_inset CommandInset label
LatexCommand label
name "alg:04-Pseudocode_radio_coverage_algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
State $DEM 
\backslash
gets$ DEM of the whole area.
\end_layout

\begin_layout Plain Layout


\backslash
Comment $O(M)$
\end_layout

\begin_layout Plain Layout


\backslash
State $Clutter 
\backslash
gets$ signal losses due to clutter of the whole area.
\end_layout

\begin_layout Plain Layout


\backslash
Comment $O(M)$
\end_layout

\begin_layout Plain Layout


\backslash
State $T 
\backslash
gets$ transmitter configuration data.
\end_layout

\begin_layout Plain Layout


\backslash
Comment $O(n)$
\end_layout

\begin_layout Plain Layout


\backslash
ForAll{$t 
\backslash
in T$}
\end_layout

\begin_layout Plain Layout

	
\backslash
Comment $O(n 
\backslash
cdot m^2)$
\end_layout

\begin_layout Plain Layout

	
\backslash
State $DEM_{t} 
\backslash
gets $ DEM area within transmission radius of ${t}$
\end_layout

\begin_layout Plain Layout

	
\backslash
Comment $O(m)$
\end_layout

\begin_layout Plain Layout

	
\backslash
State $Clut_{t} 
\backslash
gets $ Clutter area within transmission radius ${t}$
\end_layout

\begin_layout Plain Layout

	
\backslash
Comment $O(m)$
\end_layout

\begin_layout Plain Layout

	
\backslash
State $LoS_{t} 
\backslash
gets$ LineOfSight ($DEM_{t}$)
\end_layout

\begin_layout Plain Layout

	
\backslash
Comment $O(m^2)$
\end_layout

\begin_layout Plain Layout

	
\backslash
State $PL_{t} 
\backslash
gets$ PathLoss ($DEM_{t}, Clut_{t}, LoS_{t}$)
\end_layout

\begin_layout Plain Layout

	
\backslash
Comment $O(m^2)$
\end_layout

\begin_layout Plain Layout

	
\backslash
State $Diag_{t} 
\backslash
gets $ Antenna diagram of ${t}$ 
\end_layout

\begin_layout Plain Layout

	
\backslash
Comment $O(1)$
\end_layout

\begin_layout Plain Layout

	
\backslash
State $PL_{t} 
\backslash
gets$ AntennaInfluence ($Diag_{t}, PL_{t}$)
\end_layout

\begin_layout Plain Layout

	
\backslash
Comment $O(m)$
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
ForAll{$t 
\backslash
in T$}
\end_layout

\begin_layout Plain Layout

	
\backslash
Comment $O(n 
\backslash
cdot m)$
\end_layout

\begin_layout Plain Layout

	
\backslash
State $CoveragePrediction 
\backslash
gets$ PathLossAggregation ($t, PL_{t}$)
\end_layout

\begin_layout Plain Layout

	
\backslash
Comment $O(m)$
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Return $CoveragePrediction$
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this section, the time complexity of the radio-coverage prediction algorithm
 is presented, the pseudo-code of which is 
\shape italic
\emph on
listed
\shape default
\emph default
 in Algorithm
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "alg:04-Pseudocode_radio_coverage_algorithm"

\end_inset

.
\end_layout

\begin_layout Standard
The algorithm starts by loading the input DEM and clutter data.
 Both RSGs should account for the same area and resolution, consequently
 containing the same number of pixels, 
\begin_inset Formula $M$
\end_inset

.
 The transmitter data is then loaded into set 
\begin_inset Formula $T$
\end_inset

, the cardinality of which is denoted as 
\begin_inset Formula $n=|T|$
\end_inset

.
 For each transmitter 
\begin_inset Formula $t\in T$
\end_inset

, a smaller subarea of the DEM and clutter data, denoted as 
\begin_inset Formula $DEM_{t}$
\end_inset

 and 
\begin_inset Formula $Clut_{t}$
\end_inset

, respectively, is delimited around 
\begin_inset Formula $t$
\end_inset

, based on a given transmission radius.
 The number of pixels within this sub-area is denoted as 
\begin_inset Formula $m$
\end_inset

, and its value is the same for all 
\begin_inset Formula $t\in T$
\end_inset

.
 The visibility for an RSG pixel is computed using the 
\emph on
LineOfSight
\emph default
 function, by walking from the antenna of the transmitter to the given pixel
 element, along the elements intersected by a LOS, until either the visibility
 is blocked, or the target is reached
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "DeFloriani-Applications_of_computational_geometry_to_geographic_information_systems:1999"

\end_inset

.
 Regarding the 
\emph on
PathLoss 
\emph default
function, whenever a receiver point is in NLOS, the walking path from the
 transmitter has to be inspected for obstacles, calculating the diffraction
 losses for each of them, i.e., 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $K(d_{(x,y)})$
\end_inset

 from Equation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:04-Hata_NLOS"

\end_inset

).
 Hence, its quadratic complexity, which dominates the complexity of the
 algorithm, together with 
\emph on
LineOfSight
\emph default
, resulting in an algorithmic complexity denoted by:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
O(M+n\cdot m^{2}).
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
On the one hand, 
\begin_inset Formula $n$
\end_inset

 will generally be many orders of magnitude smaller than 
\begin_inset Formula $m^{2}$
\end_inset

, although its computational-time complexity is relevant for practical use.
 For example, assuming the radio-coverage prediction for one transmitter
 completes in around 15
\begin_inset space ~
\end_inset

seconds using a serial implementation, the prediction for a mobile network
 comprising 10,240 transmitters would have an execution time of almost two
 days.
 On the other hand, when the input data correspond to a large geographical
 area, and only one transmitter is selected with a narrow calculation radius,
 i.e., 
\begin_inset Formula $M$
\end_inset

 is large, 
\begin_inset Formula $n=1$
\end_inset

 and 
\begin_inset Formula $m$
\end_inset

 is small, then 
\begin_inset Formula $O(M)$
\end_inset

 will donimate the time complexity of the algorithm.
\end_layout

\begin_layout Subsection
Design of the parallel version 
\begin_inset CommandInset label
LatexCommand label
name "sub:04-Design_of_the_parallel_version"

\end_inset


\end_layout

\begin_layout Standard
The focus here is on the practical usability and performance of PRATO.
 The parallel implementation aims at overcoming the computational-time constrain
ts that prevent a serial implementation from tackling bigger problem instances
 in a feasible amount of time.
\end_layout

\begin_layout Standard
A major drawback of the GRASS as a parallelization environment is that it
 is not thread-safe, meaning that concurrent changes to the same data set
 have an undefined behavior
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Blazek_GRASS_server:2004"

\end_inset

.
 One technique to overcome this problem is to abstract the spatial data
 from the GRASS.
 For example, in
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Huang-Explorations_of_the_implementation_of_a_parallel_IDW_algorithm_in_a_Linux_cluster:2011"

\end_inset

, the authors achieved the GRASS abstraction by introducing a 
\emph on
Point 
\emph default
structure with four 
\emph on
double
\emph default
 attributes, where each pixel of the RSG is mapped to an instance of this
 structure.
 Another possibility is for one of the processes, e.g., the master, to read
 entire rows or columns of data before dispatching them for processing to
 the workers 
\begin_inset CommandInset citation
LatexCommand citep
key "Akhter_Porting_GRASS_raster_module_to_distributed_computing:2007,Huang-Explorations_of_the_implementation_of_a_parallel_IDW_algorithm_in_a_Linux_cluster:2011"

\end_inset

.
 In this case, an independence between row/column calculations is required,
 which is a problem-specific property.
 Here, abstraction from the GRASS is achieved by loading each spatial-data
 set into a separate 2D matrix of basic data-type elements, e.g., 
\emph on
float
\emph default
 or 
\emph on
double
\emph default
 depending on the desired accuracy.
 Each matrix is then assigned the geographical location of the closest corner
 to the origin of the map-projection system used, e.g., the lower-left corner
 for the transverse Mercator map projection over central Europe.
 It follows that the geographical location of any element within the matrix
 is calculated as the combination of the geographical location of the matrix
 and the offset of the target element (see Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Spatial_data_location_mapping"

\end_inset

).
 The advantage of this technique is having the geographical location of
 a pixel readily available with a minimum memory footprint.
 Moreover, a convenient consequence of this abstraction schema is that worker
 processes are completely independent of the GRASS, thus significantly simplifyi
ng the deployment of the parallel implementation over multiple computing
 hosts.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/spatial_data_projection.eps
	lyxscale 50
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Example of a geographical-location mapping of the input-spatial data into
 a 2D matrix, the lower-left corner of which indicates the nearest point
 to the origin of the map-projection system.
\begin_inset CommandInset label
LatexCommand label
name "fig:04-Spatial_data_location_mapping"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the area of geographical-information science, the master-worker paradigm
 has been successfully applied by several authors
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Akhter-GRASS_GIS_on_high_performance_computing_with_MPI_OpenMP_and_Ninf-G:2010,Akhter_Porting_GRASS_raster_module_to_distributed_computing:2007,Campos_Parallel_modelling_in_GIS:2012,Guan_A_parallel_computing_approach_to_fast_geostatistical_areal_interpolation:2011,Huang-Explorations_of_the_implementation_of_a_parallel_IDW_algorithm_in_a_Linux_cluster:2011,Tabik-High_performance_three_horizon_composition_algorithm_for_large_scale_terrains:2011,Tabik-Optimal_tilt_and_orientation_maps_a_multi_algorithm_approach_for_heterogeneous_multicore_GPU_systems:2013"

\end_inset

.
 However, this technique presents certain issues that prevent the full exploitat
ion of the available computing resources when deployed over several networked
 computers.
 Specifically, the problem refers to network saturation and idle processes
 within the master-worker model.
 Generally speaking, a single communicating process, e.g., the master, is
 usually not able to saturate the network connection of a node.
 Using more than one MPI process per node might solve this problem, but
 possible rank-ordering problems may appear, thus restricting the full utilizati
on of the network
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Rabenseifner-Hybrid_MPI_OpenMP_parallel_programming_on_clusters_of_multicore_nodes:2009"

\end_inset

.
 Additionally, the hardware-exploitation level is difficult to measure when
 the parallelization involves only one computing node
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Tabik-High_performance_three_horizon_composition_algorithm_for_large_scale_terrains:2011,Tabik-Optimal_tilt_and_orientation_maps_a_multi_algorithm_approach_for_heterogeneous_multicore_GPU_systems:2013"

\end_inset

 (because no network communication is required), or only a few processes
 deployed over a handful of nodes
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Huang-Explorations_of_the_implementation_of_a_parallel_IDW_algorithm_in_a_Linux_cluster:2011"

\end_inset

.
 
\end_layout

\begin_layout Standard
Another issue appears when the master process executes the MPI code, in
 which case other processes sleep, making a serial use of the communication
 component of the system.
 Consequently, the master process becomes the bottleneck of the parallel
 implementation as the number of worker processes grows.
 This situation is also common when dealing with the metadata of a spatial
 region, which may relate to several elements of a RSG, making it a frequent
 cause of load imbalance
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Gong_Parallel_agent_based_simulation_of_individual_level_spatial_interactions_within_a_multicore_computing_environment:2012,Hawick_Distributed_frameworks_and_parallel_algorithms_for_processing_large_scala_geographic_data:2003,Widener_Developing_a_parallel_computational_implementation_of_AMOEBA:2012"

\end_inset

.
 In PRATO, the transmitter configuration and its antenna diagram represent
 metadata that are complementary to the sub-region that a transmitter covers.
\end_layout

\begin_layout Standard
Hybrid MPI-OpenMP implementations
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Tabik-High_performance_three_horizon_composition_algorithm_for_large_scale_terrains:2011,Tabik-Optimal_tilt_and_orientation_maps_a_multi_algorithm_approach_for_heterogeneous_multicore_GPU_systems:2013"

\end_inset

, in which no MPI calls are issued inside the OpenMP-parallel regions, also
 fail to saturate the network
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Rabenseifner-Hybrid_MPI_OpenMP_parallel_programming_on_clusters_of_multicore_nodes:2009"

\end_inset

.
 A possible solution to this problem is to improve the communication overlap
 among the processes.
 To this end, PRATO features non-blocking point-to-point MPI operations,
 and an independent thread in the worker process that saves the intermediate
 results into a DB.
 One such database system per computer cluster is used, which also serves
 the input data to the GRASS, in order to aggregate the partial results
 of the path-loss predictions or to visualize them.
 It is important to note that any kind of DB may be used, e.g., relational,
 distributed
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Ozsu_Principles_of_distributed_database_systems:2011"

\end_inset

 or even those of the NoSQL type
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Stonebraker_SQL_databases_vs_NoSQL_databases:2010"

\end_inset

.
 Nevertheless, a central, relational-database system is used here, since
 they are the most popular and widely available ones.
 Additionally, the non-blocking message-passing technique used to distribute
 the work-load among the nodes provides support for heterogeneous environments.
 As a result, computing nodes featuring more capable hardware receive more
 work than those with weaker configurations, thus ensuring a better utilization
 of the available computing resources despite hardware diversity, and improved
 load balancing.
\end_layout

\begin_layout Subsubsection
Master process 
\begin_inset CommandInset label
LatexCommand label
name "sub:04-Master-process"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/master_process_flow_diagram.eps
	width 55col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Flow diagram of the master process.
\begin_inset CommandInset label
LatexCommand label
name "fig:04-Master_process_flow_diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/master_processing_loop_flow_diagram.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Flow diagram of the 
\begin_inset Quotes eld
\end_inset

Processing loop
\begin_inset Quotes erd
\end_inset

 step of the master process.
\begin_inset CommandInset label
LatexCommand label
name "fig:04-Processing_loop_in_master_process"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The master process, the flow diagram of which is given in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Master_process_flow_diagram"

\end_inset

, is the only component that runs within the GRASS environment.
 As soon as the master process starts, the input parameters are read.
 This step corresponds to 
\begin_inset Quotes eld
\end_inset

Read input data
\begin_inset Quotes erd
\end_inset

 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Master_process_flow_diagram"

\end_inset

, and it is carried out in a similar way as in the serial version.
 The next step delivers the metadata that is common to all the transmitters
 to all the processes (see 
\begin_inset Quotes eld
\end_inset

Metadata broadcasting
\begin_inset Quotes erd
\end_inset

 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Master_process_flow_diagram"

\end_inset

).
 Before distributing the work among the worker processes, the master process
 proceeds to decompose the loaded raster data into 2D matrices of basic-data-typ
e elements, e.g., 
\emph on
float
\emph default
 or 
\emph on
double
\emph default
, before dispatching them to the multiple worker processes.
 In this case, the decomposition applies to the DEM and the clutter data
 only, but it could be applied to any point-based data set.
 In the next step, the master process starts an asynchronous message-driven
 processing loop (see 
\begin_inset Quotes eld
\end_inset

Processing loop
\begin_inset Quotes erd
\end_inset

 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Master_process_flow_diagram"

\end_inset

), the main task of which is to assign and distribute the sub-region and
 configuration data of different transmitters among the idle worker processes.
\end_layout

\begin_layout Standard
The flow diagram shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Processing_loop_in_master_process"

\end_inset

 illustrates the 
\begin_inset Quotes eld
\end_inset

Processing loop
\begin_inset Quotes erd
\end_inset

 step of the master process.
 In the processing loop, the master process starts by checking the available
 worker processes, that might calculate the radio-coverage prediction for
 the next transmitter.
 It is worth pointing out that this step also serves as a stopping condition
 for the processing loop itself (see 
\begin_inset Quotes eld
\end_inset

Any worker still on?
\begin_inset Quotes erd
\end_inset

 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Processing_loop_in_master_process"

\end_inset

).
 The active worker processes inform the master process that they are ready
 to compute by sending an idle message (see 
\begin_inset Quotes eld
\end_inset

Wait for idle worker
\begin_inset Quotes erd
\end_inset

 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Processing_loop_in_master_process"

\end_inset

).
 The master process then announces to the idle worker process that it is
 about to receive new data for the next calculation, and it dispatches the
 complete configuration of the transmitter to be processed (see 
\begin_inset Quotes eld
\end_inset

Send keep-alive message
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Send transmitter data
\begin_inset Quotes erd
\end_inset

 steps, respectively, in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Processing_loop_in_master_process"

\end_inset

).
 This is only done in the case that there are transmitters for which the
 coverage prediction has yet to be calculated (see 
\begin_inset Quotes eld
\end_inset

Any transmitters left?
\begin_inset Quotes erd
\end_inset

 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Processing_loop_in_master_process"

\end_inset

).
 The processing loop of the master process continues distributing the transmitte
r data among the worker processes, which asynchronously become idle as they
 finish the radio-prediction calculations they have been assigned by the
 master process.
 When there are no more transmitters left, all the worker processes announcing
 they are idle will receive a shutdown message from the master process,
 indicating to them that they should stop running (see 
\begin_inset Quotes eld
\end_inset

Send stop message
\begin_inset Quotes erd
\end_inset

 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Processing_loop_in_master_process"

\end_inset

).
 The master process will keep doing this until all the worker processes
 have finished (see 
\begin_inset Quotes eld
\end_inset

Any worker still on?
\begin_inset Quotes erd
\end_inset

 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Processing_loop_in_master_process"

\end_inset

), thus fulfilling the stopping condition of the processing loop.
\end_layout

\begin_layout Standard
Finally, the last step of the master process is devoted to creating the
 final output of the calculation, e.g., a raster map (see 
\begin_inset Quotes eld
\end_inset

Create final coverage prediction
\begin_inset Quotes erd
\end_inset

 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Master_process_flow_diagram"

\end_inset

).
 The final coverage prediction of all the transmitters is an aggregation
 from the individual path-loss results created by each of the worker processes
 during the 
\begin_inset Quotes eld
\end_inset

Processing loop
\begin_inset Quotes erd
\end_inset

 phase in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Master_process_flow_diagram"

\end_inset

, which provides the source data for the final raster map.
 The aggregation of the individual path-loss results is accomplished by
 issuing an SQL query over the database tables containing them, in a similar
 way as in the serial version.
\end_layout

\begin_layout Subsubsection
Worker processes on CPU
\end_layout

\begin_layout Standard
An essential characteristic of the worker processes is that they are completely
 independent of the GRASS, i.e., they do not have to run within the GRASS
 environment nor use any of the GRASS libraries to work.
 This aspect significantly simplifies the deployment phase to run PRATO
 on a computer cluster, since no GRASS installation is needed on the computing
 nodes hosting the worker processes.
\end_layout

\begin_layout Standard
One possibility to overcome the thread-safety limitation of the GRASS is
 to save the transmitter path-loss predictions through the master process,
 thus avoiding concurrent access.
 However, for the workers to send intermediate results back to the master
 process, e.g., as in
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Akhter-GRASS_GIS_on_high_performance_computing_with_MPI_OpenMP_and_Ninf-G:2010,Huang-Explorations_of_the_implementation_of_a_parallel_IDW_algorithm_in_a_Linux_cluster:2011"

\end_inset

, is a major bottleneck for the scalability of a parallel implementation.
 In such case, the scalability is limited by the master process, because
 it must serially process the received results in order to avoid inconsistencies
 due to concurrent access.
 Instead, PRATO allows each of the worker processes to output its intermediate
 results into a DB, i.e., each path-loss prediction in its own table.
 Additionally, worker processes do this from an independent thread, which
 runs concurrently with the calculation of the next transmitter received
 from the master process.
 In this way, the overlap between the calculation and communication significantl
y hides the latency created by the result-dumping task, thus making better
 use of the available system resources.
\end_layout

\begin_layout Standard
The computations of the worker processes, the flow diagram of which is given
 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Worker_process_flow_diagram"

\end_inset

, begin by receiving metadata about the transmitters and the geographical
 area from the master process during the initialization time (see 
\begin_inset Quotes eld
\end_inset

Receive broadcasted metadata
\begin_inset Quotes erd
\end_inset

 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Worker_process_flow_diagram"

\end_inset

).
\end_layout

\begin_layout Standard
After the broadcasted metadata are received by all the worker processes,
 each one proceeds to inform the master process that it is ready (i.e., in
 an idle state) to receive the transmitter-configuration data that define
 which transmitter path-loss prediction to perform (see 
\begin_inset Quotes eld
\end_inset

Send idle message
\begin_inset Quotes erd
\end_inset

 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Worker_process_flow_diagram"

\end_inset

).
 If the master process does not give the instruction to stop processing
 (see 
\begin_inset Quotes eld
\end_inset

Has stop message arrived?
\begin_inset Quotes erd
\end_inset

 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Worker_process_flow_diagram"

\end_inset

), the worker process collects the sub-region spatial data and the transmitter
 configuration (see 
\begin_inset Quotes eld
\end_inset

Receive transmitter data
\begin_inset Quotes erd
\end_inset

 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Worker_process_flow_diagram"

\end_inset

).
 In the event that a stop message is received, the worker process will wait
 for any result-dumping thread to finish (see 
\begin_inset Quotes eld
\end_inset

Wait for result-dump thread
\begin_inset Quotes erd
\end_inset

 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Worker_process_flow_diagram"

\end_inset

) before shutting down.
 The coverage calculation itself follows a similar design as the serial
 version (see 
\begin_inset Quotes eld
\end_inset

Coverage calculation
\begin_inset Quotes erd
\end_inset

 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Worker_process_flow_diagram"

\end_inset

).
\end_layout

\begin_layout Standard
As mentioned before, the worker process launches an independent thread to
 save the path-loss prediction of the target transmitter into a DB table
 (see 
\begin_inset Quotes eld
\end_inset

Threaded save path-loss to DB
\begin_inset Quotes erd
\end_inset

 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Worker_process_flow_diagram"

\end_inset

).
 It is important to note that there is no possibility of data inconsistency
 due to the saving task being executed inside a thread, since path-loss
 data from different workers belong to different transmitters and are, at
 this point of the process, mutually exclusive.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/worker_process_flow_diagram.eps
	width 90col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Flow diagram of a worker process.
\begin_inset CommandInset label
LatexCommand label
name "fig:04-Worker_process_flow_diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/master_worker_communication_diagram.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Communication diagram, showing the message passing between the master and
 a worker process.
\begin_inset CommandInset label
LatexCommand label
name "fig:04-Master_worker_communication"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Worker processes on GPU 
\begin_inset CommandInset label
LatexCommand label
name "sub:04-GPU_worker_implementation"

\end_inset


\end_layout

\begin_layout Standard
PRATO provides multi-GPU support for improving the execution performance
 on the computing nodes hosting the worker processes.
 The algorithmic adaptation from a CPU to a GPU is not a trivial task.
 This section focuses on the main modifications made to the radio-propagation
 algorithm in order for it to work on GPU hardware.
\end_layout

\begin_layout Standard
It is well known that the bandwidth of the PCI Express bus can cause a throughpu
t bottleneck when a significant amount of data is transferred between a
 CPU and a GPU in a heterogeneous system
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Gregg-Where_is_the_data:2011"

\end_inset

.
 Some researchers acknowledged that unless a full working set of data can
 fit into the memory on a GPU, the PCI Express will become the bottleneck
 of the system
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Owens-GPU_computing:2008,Schaa-Exploring_the_multiple_GPU_design_space:2009"

\end_inset

.
 For this reason, it is imperative to have as much data as possible allocated
 on the GPU itself.
\end_layout

\begin_layout Standard
In order to minimize the CPU-to-GPU memory transfers, the spatial data used
 by the radio-propagation algorithm was organized as explained in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:04-Design_of_the_parallel_version"

\end_inset

, i.e., using geographically-located, offset-based 2D matrices.
 However, the internal representation of the matrix elements was changed
 to use less memory.
 To this end, the clutter-matrix elements were represented as 
\emph on
unsigned char
\emph default
, since they express signal loss in dB.
 It follows that for the radio-propagation prediction of one transmitter,
 the following matrices should be allocated on the GPU:
\end_layout

\begin_layout Itemize
one 2D matrix containing DEM data for the target subregion, the elements
 of which are 
\emph on
float
\emph default
 or 
\emph on
double
\emph default
; 
\end_layout

\begin_layout Itemize
one 2D matrix containing clutter data for the target subregion, the elements
 of which are 
\emph on
unsigned char
\emph default
; and
\end_layout

\begin_layout Itemize
one 2D matrix containing the resulting path-loss prediction.
\end_layout

\begin_layout Standard
The dimension of all matrices is based on the transmission radius, within
 which the radio-propagation prediction should be calculated.
 The contents of the DEM and clutter matrices is constant throughout the
 calculation process.
 For this reason they were kept in texture memory to take advantage of the
 faster access time (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:02-CUDA"

\end_inset

).
 Regarding the resulting path-loss matrix, each step of the radio-prediction
 algorithm is applied over the results of the previous step (see Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Flow_diagram_serial_version"

\end_inset

 for a flow diagram of the steps involved), thus avoiding extra allocation
 on global memory or a data-transfer from/to the CPU.
\end_layout

\begin_layout Subsubsection
Master-worker communication
\end_layout

\begin_layout Standard
Similar to
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Tabik-High_performance_three_horizon_composition_algorithm_for_large_scale_terrains:2011,Tabik-Optimal_tilt_and_orientation_maps_a_multi_algorithm_approach_for_heterogeneous_multicore_GPU_systems:2013"

\end_inset

, the message-passing technique used in this work enables a better use of
 the available computing resources, both in terms of scalability and load
 balancing, while introducing a negligible overhead.
 This last point is supported by the experimental results, introduced in
 Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:04-Strong_scalability"

\end_inset

.
\end_layout

\begin_layout Standard
The first reason to implement the message-passing technique is to support
 heterogeneous computing environments.
 In particular, our approach focuses on taking full advantage of the hardware
 of each computing node, thus explicitly avoiding the bottlenecks introduced
 by the slowest computing node in the cluster.
 This problem appears when evenly distributing the data among the worker
 processes on disparate hardware, e.g., as in
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Akhter_Porting_GRASS_raster_module_to_distributed_computing:2007,Huang-Explorations_of_the_implementation_of_a_parallel_IDW_algorithm_in_a_Linux_cluster:2011"

\end_inset

, being more noticeable with a larger number of computing nodes and processes.
 In other words, computing nodes that deliver better performance have more
 calculations assigned to them.
 Moreover, in real-world scenarios, it is often the case that a large number
 of dedicated computing nodes featuring exactly the same configuration is
 difficult to find, i.e., not every organization owns a computer cluster.
\end_layout

\begin_layout Standard
A second reason for selecting a message-passing technique is related to
 the flexibility it provides for load balancing, which is of greater importance
 when dealing with extra data or information besides spatial data
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Hawick_Distributed_frameworks_and_parallel_algorithms_for_processing_large_scala_geographic_data:2003"

\end_inset

.
 This can be seen in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Processing_loop_in_master_process"

\end_inset

, where the master process, before delivering the spatial subset and transmitter
-configuration data, sends a message to the worker process, indicating that
 it is about to receive more work.
 This a priori meaningless message plays a key role in correctly supporting
 the asynchronous process communication.
 Notice that the subset of spatial data that a worker process receives is
 directly related to the transmitter for which the prediction will be calculated.
 Similar to
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Tabik-High_performance_three_horizon_composition_algorithm_for_large_scale_terrains:2011,Tabik-Optimal_tilt_and_orientation_maps_a_multi_algorithm_approach_for_heterogeneous_multicore_GPU_systems:2013"

\end_inset

, this problem-specific property enables the use of a data-decomposition
 technique based on a block partition of spatial data, e.g., the DEM and clutter
 data.
\end_layout

\begin_layout Standard
In general, there are many different ways a parallel program can be executed,
 because the steps from the different processes can be interleaved in various
 ways and a process can make non-deterministic choices
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Siegel_Verification_of_halting_properties_for_MPI_programs:2007"

\end_inset

, which may lead to situations such as race conditions
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Clemencon_MPI_Race_detection:1995"

\end_inset

 and deadlocks.
 A deadlock occurs whenever two or more running processes are waiting for
 each other to finish, and thus neither ever does.
 To prevent PRATO from deadlocking, message sending and receiving should
 be paired, i.e., an equal number of send and receive messages on the master
 and worker sides
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Siegel_Verification_of_halting_properties_for_MPI_programs:2007"

\end_inset

.
 Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Master_worker_communication"

\end_inset

 depicts the master-worker message passing, from which the transmitter-data
 transmission has been excluded for clarity.
 Notice how each idle message sent from the worker process is paired with
 an answer from the master process, whether it is a keep-alive or a stop
 message.
\end_layout

\begin_layout Section
Simulations 
\begin_inset CommandInset label
LatexCommand label
name "sec:04-Simulations"

\end_inset


\end_layout

\begin_layout Standard
Considering the large computational power needed for predicting the radio-covera
ge of a real radio network, the use of a computer cluster is recommended.
 A computer cluster is a group of interconnected computers that work together
 as a single system.
 Computer clusters typically consist of several commodity PCs connected
 through a high-speed local-area network (LAN
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "LAN"
description "Local area network."

\end_inset

) with a distributed file system, like the network file system (NFS
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "NFS"
description "Network file system."

\end_inset

)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Shepler_Network_file_system:2003"

\end_inset

.
 One such system is the DEGIMA cluster 
\begin_inset CommandInset citation
LatexCommand citep
key "Hamada_Cluster_of_GPUs:2010"

\end_inset

 at the Nagasaki Advanced Computing Center (NACC
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "NACC"
description "Nagasaki advanced computing center."

\end_inset

) of the Nagasaki University in Japan.
 This system ranked in the TOP 500 list of supercomputers until June 2012
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.top500.org
\end_layout

\end_inset

, and in June 2011 it held the third place in the Green 500 list
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.green500.org
\end_layout

\end_inset

 as one of the most energy-efficient supercomputers in the world.
\end_layout

\begin_layout Standard
This section presents the simulations, and an exhaustive analysis of the
 performance and scalability of the parallel implementation of PRATO.
 The most common usage case for PRATO is to perform a radio-coverage prediction
 for multiple transmitters.
 Therefore, a straight-forward parallel decomposition is to divide a given
 problem instance by transmitter, for which each coverage prediction is
 calculated by a separate worker process.
\end_layout

\begin_layout Standard
The following simulations were carried out on 34 computing nodes of the
 DEGIMA cluster.
 The computing nodes are connected by a LAN, over a Gigabit Ethernet interconnec
t.
 As mentioned before, the reason for using a high-end computer cluster such
 as DEGIMA is to explore, by experimentation, the advantages and drawbacks
 of the considered methods.
 However, this does not imply any loss of generality if applying these principle
s over a different group of networked computers that do not operate as a
 computer cluster.
 Moreover, PRATO also supports parallel calculation of radio-propagation
 predictions for multiple cells by distributing the processes among the
 individual cores of a single CPU.
\end_layout

\begin_layout Standard
Each computing node of DEGIMA features one of two possible configurations,
 namely:
\end_layout

\begin_layout Itemize
Intel Core i5-2500T quad-core processor CPU, clocked at 2.30 GHz, with 16
 GB of RAM; and
\end_layout

\begin_layout Itemize
Intel Core i7-2600K quad-core processor CPU, clocked at 3.40 GHz, also with
 16 GB of RAM.
\end_layout

\begin_layout Standard
During the simulation runs, the nodes equipped with the Intel i5 CPU hosted
 the worker processes, whereas the master process and the PostgreSQL database
 server (version 9.1.4) each run on a different computing node, featuring
 an Intel i7 CPU.
 The DB server performed all its I/O operations on the local file system,
 which was mounted on an 8
\begin_inset space ~
\end_inset

GB RAM disk.
 During the simulations, the path-loss predictions of 5,120 transmitters
 occupied less than 4
\begin_inset space ~
\end_inset

GB of this partition.
 No GPU hardware was used for the following simulation sets.
\end_layout

\begin_layout Standard
A 64-bit Linux operating system (Fedora distribution) was the operating
 system used.
 The message-passing implementation OpenMPI, version 1.6.1, was manually compiled
 with the distribution-supplied gcc compiler, version 4.4.4.
\end_layout

\begin_layout Subsection
Test networks
\end_layout

\begin_layout Standard
The parallel performance of PRATO was tested with real radio networks of
 different sizes.
 In order to create the synthetic test data sets with an arbitrary number
 of transmitters, a group of 2,000 transmitters of a real network was used.
 The configuration parameters of these transmitters resembled those of the
 LTE network deployed in Slovenia by Telekom Slovenije, d.d., which were,
 in turn, randomly replicated and distributed over the whole target area.
 The path-loss predictions were calculated using the radio-propagation model
 introduced in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:04-Radio_propagation_model"

\end_inset

.
 The DEM area, as well as the clutter data, covered 20,270
\begin_inset space ~
\end_inset

km
\begin_inset Formula $^{2}$
\end_inset

 with a pixel resolution of 25
\begin_inset space ~
\end_inset

m
\begin_inset Formula $^{2}$
\end_inset

.
 The clutter data contained different levels of signal loss due to land
 usage.
 For all the points within a radius of 20
\begin_inset space ~
\end_inset

km around each transmitter, a receiver positioned 1.5
\begin_inset space ~
\end_inset

m above the ground was assumed, and the frequency was set to 1,843
\begin_inset space ~
\end_inset

MHz.
\end_layout

\begin_layout Subsection
Weak scalability
\end_layout

\begin_layout Standard
The weak-scalability experiments are meant to analyze the scalability of
 the parallel implementation in cases where the workload assigned to each
 process (one MPI process per processor core) remains constant as the number
 of processor cores is increased.
 It follows that the number of transmitters deployed over the target area
 is directly proportional to the number of processor cores and worker processes.
 This was accomplished by assigning a constant number of transmitters per
 core, while increasing the number of cores hosting the worker processes.
 Here, the following numbers of transmitters per worker/core were tested
 {5,
\begin_inset space ~
\end_inset

10,
\begin_inset space ~
\end_inset

20,
\begin_inset space ~
\end_inset

40,
\begin_inset space ~
\end_inset

80}, by progressively doubling the number of worker processes from 1 to
 64.
\end_layout

\begin_layout Standard
Problems that are particularly well-suited for parallel computing exhibit
 computational costs that are linearly dependent on the size of the problem.
 This property, also referred to as algorithmic scalability, means that
 proportionally increasing both the problem size and the number of cores
 results in a roughly constant time to solution.
\end_layout

\begin_layout Standard
The master-worker (MW
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "MW"
description "Master-worker parallel paradigm."

\end_inset

) configuration performs result aggregation continuously, i.e., while receiving
 the intermediate results from the worker processes.
 In contrast, the master-worker-DB (MWD
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "A"
symbol "MWD"
description "Master-worker-database parallel paradigm."

\end_inset

) setup performs the result aggregation as the final step.
 This set of experiments is meant to investigate how the proposed MWD technique
 compares with the classic MW approach in terms of scalability when dealing
 with a constant computational load per core.
\end_layout

\begin_layout Standard
An important fact about the presented simulations when using multi-threaded
 implementations is to avoid oversubscribing a computing node.
 For example, if deploying four worker processes over a quad-core CPU, the
 extra threads will have a counter effect on the parallel efficiency, since
 the CPU resources would be exhausted, which slows the whole process down.
 For this reason, we have deployed three worker processes per computing
 node, leaving one core free for executing the extra threads.
 
\end_layout

\begin_layout Subsubsection*
Results
\end_layout

\begin_layout Standard
The results represent the average running time out of a set of 20 independent
 simulation runs, for which the transmitters and the rank ordering of the
 worker processes were randomly selected.
 The collected running times for the weak-scalability experiments are shown
 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Weak_scalability_time"

\end_inset

.
 All the measurements express wall-clock times in seconds for each setup
 and problem instance, defined as the number of transmitters per process
 (Tx/process).
 The wall-clock time represents the real time that elapses from the start
 of the master process to its end, including the time that passes while
 waiting for the resources to become available.
 The running-time improvements of the MWD versus the MW setup are shown
 in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:04-Weak_scaling-time_gain"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/weak_scaling-time_plot.eps
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Measured wall-clock time for weak-scalability experiments, featuring MW
 and MWD setups.

\emph default
 
\emph on
Experiments allocated one MPI worker process per core.
\begin_inset CommandInset label
LatexCommand label
name "fig:04-Weak_scalability_time"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Running-time gain (in percent) of the simulations for the weak-scalability
 of the MWD setup relative to the classic MW approach.
\begin_inset CommandInset label
LatexCommand label
name "tab:04-Weak_scaling-time_gain"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="8">
<features booktabs="true" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row bottomspace="default">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Number of cores
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
TX/core
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
64
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
-11.39
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
-10.42
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
-11.14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
-0.95
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
11.75
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
26.15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
32.53
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
-5.84
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
-7.78
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
-7.67
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0.91
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
12.81
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
33.28
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
33.55
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
-8.59
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
-10.88
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
-1.04
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1.95
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
14.29
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
35.23
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
35.27
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
-5.26
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
-6.90
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
-3.68
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
-0.67
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
17.27
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
36.23
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
36.65
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
80
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
-5.29
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
-7.11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
-3.20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
-0.31
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
17.94
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
36.32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
36.57
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The time measurements observed from the weak-scalability results show that
 the classic MW approach performs well for up to four worker processes.
 When using eight worker processes, the MW setup is practically equivalent
 to the MWD approach, indicating that the master process is being fully
 exploited.
 When increasing the problem size and the number of worker processes to
 16, the running-time gain is already clear, favoring the MWD configuration.
 This gain keeps growing, although slower, as we increase the number of
 worker processes to 32 and 64, confirming the hypothesis that in a classic
 MW approach, the parallel efficiency is bounded by the capacity of the
 master process to serve an increasing number of worker processes.
 Interestingly, the gain when using 32 and 64 worker processes is almost
 the same.
 After further investigation, the reason for this behavior was found: the
 new bottleneck was the LAN being completely saturated by the worker processes.
 Consequently, they have to wait for the network resources to become available
 before sending or receiving data, which is not the case when running the
 MW setup.
 Therefore, using the MWD approach a hardware constraint is hit, meaning
 that the bottleneck is no longer at the implementation level.
 Moreover, since the master process is far from overloaded when serving
 64 worker processes, it can be expected that the MWD approach will keep
 scaling if a faster network infrastructure is used, e.g., 10-gigabit Ethernet
 or InfiniBand.
\end_layout

\begin_layout Standard
Certainly, the parallel version of PRATO scales better using the MWD approach,
 when challenged with a large number of transmitters (5,120 for the biggest
 instance) over 64 cores.
 This fact shows PRATO would be able to calculate the radio-coverage prediction
 for real networks in a feasible amount of time, since many operational
 radio networks have already deployed a comparable number of transmitters,
 e.g., the 3G network within the Greater London Authority area, in the UK
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Number_of_base_stations_in_England"

\end_inset

.
 For a more in-depth discussion and experimentation about real-world planning
 scenarios, see Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:08-Real-world_network_planning"

\end_inset

.
\end_layout

\begin_layout Standard
Not being able to achieve perfect weak scalability using the MWD setup is
 due to a number of factors.
 Specifically, the overhead time of the serial sections of the parallel
 process grows proportionally with the number of cores, e.g., aggregation
 of the intermediate results, although the total contribution of this overhead
 remains low for large problem sizes.
 Moreover, the communication overhead grows linearly with the number of
 cores used.
 Consequently, the findings of Huang et al.
 
\begin_inset CommandInset citation
LatexCommand citep
key "Huang-Explorations_of_the_implementation_of_a_parallel_IDW_algorithm_in_a_Linux_cluster:2011"

\end_inset

 can be confirmed, who concluded that the data-set size should be large
 enough for the communication overhead to be hidden by the calculation time.
 This ensures profitable parallelization in terms of running-time reduction.
\end_layout

\begin_layout Subsection
Strong scalability 
\begin_inset CommandInset label
LatexCommand label
name "sub:04-Strong_scalability"

\end_inset


\end_layout

\begin_layout Standard
This set of simulations is meant to analyze the impact of increasing the
 number of computing cores for a given problem size, i.e., the number of transmitt
ers deployed over the target area does not change, but only the number of
 worker processes used is increased.
 Here, the following number of transmitters were tested {1,280,
\begin_inset space ~
\end_inset

2,560,
\begin_inset space ~
\end_inset

5,120}, by gradually doubling the number of workers from 1 to 64 for each
 problem size.
\end_layout

\begin_layout Subsubsection*
Results
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/strong_scaling-time_plot.eps
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Measured wall-clock time for strong-scalability experiments, featuring MW
 and MWD setups.

\emph default
 
\emph on
Experiments assigned one MPI worker process per core.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:04-Strong_scalability_time"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Similar to the weak-scalability experiments, the time measurements plotted
 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Strong_scalability_time"

\end_inset

 show that, when applying a classic MW approach, the 
\shape italic
\emph on
running-time reduction
\shape default
\emph default
 starts flattening if more than eight worker processes were used.
 Moreover, the running times for 16, 32 and 64 worker processes are the
 same, i.e., they do not improve due to the master process being 
\shape italic
\emph on
saturated
\shape default
\emph default
.
 In contrast, when using the proposed MWD technique, the running-time reduction
 improves for up to 32 worker processes, after which there is no further
 improvement since the network was being fully exploited.
 These results clearly show that when applying parallelization using a larger
 number of worker processes, the master process becomes the bottleneck of
 the MW approach.
 When using the MWD configuration, a steady running-time reduction is observed,
 until a hardware constraint is hit, e.g., the network infrastructure.
\end_layout

\begin_layout Standard
The overhead of sending/receiving asynchronous messages in order to support
 heterogeneous systems was also measured.
 It was found that this overhead never exceeds 0.02% of the total running
 time for the MW experiments, and 0.01% for the MWD experimental set.
\end_layout

\begin_layout Subsubsection
Speedup
\end_layout

\begin_layout Standard
In order to further analyze how well the PRATO scales using the MW and MWD
 approaches, the performance of the parallel implementation in terms of
 its speedup was measured, which is defined as:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
S(NP)=\frac{execution\, time\, for\, base\, case}{execution\, time\, for\, NP\, cores},\label{eq:04-Speedup}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $NP$
\end_inset

 is the number of cores executing the worker processes.
 The parallel implementation running on only one core was the base case
 for comparisons.
 The serial implementation is not a good base comparison for the parallel
 results as it does not reuse the resources between each transmitter-coverage
 calculation and it does not overlap the I/O operations with the transmitter
 computations.
 In practice, this means that several concatenated runs of the serial version
 would be considerably slower than the single-worker configuration.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "48text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/strong_scaling-speedup_plot.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Average speedup for the strong-scalability experiments.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:04-Strong_scalability_speedup"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "48text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/strong_scaling-efficiency_plot.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Average parallel efficiency for the strong-scalability experiments.

\emph default
 
\emph on

\begin_inset CommandInset label
LatexCommand label
name "fig:04-Strong_scalability_efficiency"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Using the speedup metric, linear scaling is achieved when the obtained speedup
 is equal to the total number of processors used.
 However, it should be noted that a perfect speedup is almost never achieved,
 due to the existence of serial stages within an algorithm and the communication
 overhead of the parallel implementation.
\end_layout

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Strong_scalability_speedup"

\end_inset

 shows the average speedup of the parallel implementation for up to 64 worker
 processes, using the standard MW method and the proposed MWD approach.
 The average speedup was calculated for the three different problem instances,
 i.e., 1,280, 2,560, and 5,120 transmitters deployed over the target area.
 The number of transmitters used in these problem sizes is comparable to
 several real-world radio networks that were already deployed in England,
 e.g., Hampshire County with 227 BSs, West Midlands with 414 BSs, and Greater
 London Authority with 1,086 BSs 
\begin_inset CommandInset citation
LatexCommand citep
key "Number_of_base_stations_in_England"

\end_inset

.
 Note that it is common for a single base station to host multiple transmitters.
 
\end_layout

\begin_layout Standard
The plotted average speedup clearly shows the minimal overhead of the MWD
 approach when using a small number of worker processes.
 This overhead accounts for the final aggregation of the intermediate results
 at the DB, which in the MW configuration is performed along worker processing.
 Like before, the DB component allows the parallel implementation to fully
 exploit the available computing resources when deploying a larger number
 of worker processes, until the network-capacity limit is met.
 Of course, these results are directly correlated with the wall-clock times
 shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Strong_scalability_time"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Efficiency
\end_layout

\begin_layout Standard
Another measure to study how well PRATO utilizes the available computing
 resources considers the parallel efficiency of the implementation.
 The definition of parallel efficiency is as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
E(NP)=\frac{S(NP)}{NP},
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $S(NP)$
\end_inset

 is the speedup as defined in Equation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:04-Speedup"

\end_inset

), and 
\begin_inset Formula $NP$
\end_inset

 is the number of cores executing worker processes.
 Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Strong_scalability_efficiency"

\end_inset

 shows the average parallel efficiency of the parallel implementation for
 different problem sizes, as the number of processing cores was increased.
 Like for the speedup measure, the average parallel efficiency from the
 same problem instances was calculated.
\end_layout

\begin_layout Standard
The ideal case for a parallel application would be to utilize all the available
 computing resources, in which case the parallel efficiency would always
 be equal to one as the core count increases.
 From the plot in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:04-Strong_scalability_efficiency"

\end_inset

, it can be observed that the efficiency of the MWD approach is better than
 in the MW case for larger number of processes, and as long as there was
 available capacity at the LAN level.
 In accordance to the previous analysis, the under utilization of the computing
 resources is more significant when the master process is overloaded (in
 the MW case) than when the network infrastructure is saturated (in the
 MWD case).
 The lower efficiency is directly proportional to the number of idle worker
 processes that wait either for the master process (MW case) or for network
 access (MWD case).
\end_layout

\begin_layout Standard
Overall, the experimental results confirm that the objective of fully exploiting
 the available hardware resources is accomplished when applying the presented
 MWD approach, thus improving the scalability and efficiency of PRATO when
 compared to a traditional MW technique.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Subsection
Performance analysis 
\begin_inset CommandInset label
LatexCommand label
name "sub:04-GPU_performance"

\end_inset


\end_layout

\begin_layout Plain Layout
<Experiments not yet finished ...???>
\end_layout

\begin_layout Plain Layout
---- De la tanda de experimentos para real-world network planning (ultimo
 capitulo), hacemos con CPU only y master CPU+workers GPU, y comparar los
 wall-clock times ----
\end_layout

\begin_layout Plain Layout
---- Los resultados de estos experimentos los usamos en el siguiente capitulo,
 en donde se muestra el speedup (23.2 Performance analysis) ----
\end_layout

\end_inset


\end_layout

\begin_layout Section
Summary 
\begin_inset CommandInset label
LatexCommand label
name "sec:04-Summary"

\end_inset


\end_layout

\begin_layout Standard
PRATO, a parallel radio-coverage prediction tool for radio networks, has
 been presented in this chapter.
 The tool is intended to be used for radio-network planning analysis and
 decision support.
 Its high-performance capabilities make it ideal for automatic-optimization
 tasks that require a large number of evaluations.
\end_layout

\begin_layout Standard
The parallel implementaion of PRATO includes a novel parallel technique
 for master-worker configurations.
 The introduced MWD technique, which combines the use of a DB system with
 a work-pool approach, delivers improved performance when compared with
 a traditional MW setup.
 Moreover, the presented system provides parallel and asynchronous computation
 that is completely independent of the GIS used, in this case the GRASS
 environment.
 Consequently, a GIS installation is only needed on the master node, thus
 simplifying the required system setup and greatly enhancing the applicability
 of this methodology in different environments.
\end_layout

\begin_layout Standard
The extensive simulations, performed on the DEGIMA cluster of the Nagasaki
 Advanced Computing Center, were analyzed to determine the level of scalability
 of the implementation, as well as the impact of the presented methods for
 parallel-algorithm design aimed at spatial-data processing.
 The conducted analyses show that when using the MWD approach, PRATO is
 able to calculate the radio-coverage prediction of real-world radio networks
 in a reduced amount of time.
 Moreover, the experimental results show that PRATO has a better scalability
 when using the MWD approach than the standard MW setup, since it is able
 to completely saturate the network infrastructure of the computer cluster.
 These promising results also show the great potential of the MWD approach
 for parallelizing different time-consuming tasks dealing with spatial data,
 where DBs form an intrinsic part of almost all GIS.
 Furthermore, the automatic optimization of radio networks, where a large
 number of radio-propagation predictions take part in the evaluation step
 of the optimization process, can also an benefit from the improved performance
 of PRATO.
 Indeed, this last point will be further discussed and validated in the
 following chapters.
\end_layout

\begin_layout Standard
The performance of the worker processes has been additionally improved by
 including the implementation of the radio-propagation algorithm on GPU.
 The use of GPU hardware is optional, i.e., it is exploited only if it is
 available on the computing nodes that host the worker processes.
 The experimental simulations showed a significant speedup due to the GPU
 implementation, when compared to the CPU-only version.
\end_layout

\begin_layout Standard
To the best of the author's knowledge, neither the MWD parallel technique
 nor the parallel implementation of the radio-prediction algorithm as presented
 in this chapter, have yet been described in the related literature.
\end_layout

\end_body
\end_document
