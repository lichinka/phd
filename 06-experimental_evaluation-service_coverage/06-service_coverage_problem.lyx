#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass book
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 0
\use_mathdots 0
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Experimental evaluation: the service coverage problem 
\begin_inset CommandInset label
LatexCommand label
name "chap:Experimental-evaluation-the-service-coverage-problem"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% First paragraph has no indentation.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the context of coverage planning and control, the power of the CPICH
 signal determines the coverage area of the cell.
 It also impacts the network capacity, and thus the quality of service.
 Pilot power is the parameter that allows us to control the strength of
 the CPICH signal.
 A higher power for pilot signals means better coverage.
 On the other hand, more pilot power translates in decreased network capacity.
\end_layout

\begin_layout Standard
We consider the problem of minimizing the total amount of pilot power subject
 to a full coverage constraint.
 Our optimization approach, based on parallel autonomous agents, gives very
 good solutions to the problem within an acceptable amount of time.
 The parallel implementation takes full advantage of GPU hardware in order
 to achieve impressive speed-up.
 We report the results of our experiments for three UMTS networks of different
 sizes based on a real network currently deployed in Slovenia.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The coverage problem in third-generation (3G) mobile networks has received
 a great deal of attention in the last years.
 Its complexity demands the confluence of different skills in areas such
 as propagation of radio signals, telecommunications and information systems,
 among others.
\end_layout

\begin_layout Standard
The problem becomes even more complex as conflicting measures to compare
 different proposed solutions are taken into account.
 These aspects include network capacity, quality of service, service coverage,
 and, recently, issues related with human exposure to electromagnetic fields
 generated by base station antennas 
\begin_inset CommandInset citation
LatexCommand citep
key "Esposito_Genetic.optimization.for.optimum.3G.network.planning:2010"

\end_inset

.
 Public opinion has been extremely sensitive regarding this issue, and thus
 many countries have already imposed safety standards to limit the electromagnet
ic field levels.
\end_layout

\begin_layout Standard
It is clear that even after almost 10 years after the launch of the first
 commercial UMTS network, service coverage planning remains a key problem
 that all mobile operators have to deal with.
 Its intricacy arises from the wide range of different combinations of configura
tion parameters and their evaluation-time complexity.
 One crucial parameter, which is mainly subject of adjustment, is the transmit
 power of the common pilot channel (CPICH).
 The CPICH transmit power is common to many different planning and optimization
 problems in UMTS networks 
\begin_inset CommandInset citation
LatexCommand citep
key "Nawrocki_Understanding:2006"

\end_inset

.
\end_layout

\begin_layout Standard
The CPICH transmits in the downlink of a UMTS cell system.
 The transmit power is usually between 5% and 10% of the total power available
 at the base station 
\begin_inset CommandInset citation
LatexCommand citep
key "Holma_WCDMA.for.UMTS:2005"

\end_inset

.
 The capacity of a cell is limited by the amount of available power at the
 base station and the interference level at the mobile terminal.
 The coverage area of any cell is controlled by changing its pilot power,
 which consequently modifies the service area of the network.
\end_layout

\begin_layout Standard
From the network perspective, minimizing pilot power usage leaves more power
 available for increased network capacity.
 This is especially important if the traffic and other channels are configured
 relative to CPICH 
\begin_inset CommandInset citation
LatexCommand citep
key "Holma_WCDMA.for.UMTS:2005"

\end_inset

.
 Moreover, as applications demand for mobile internet access and data services
 increases 
\begin_inset CommandInset citation
LatexCommand citep
key "Cunningham_Network.growth.theory.and.evidence:2010"

\end_inset

, so does the pressure on existing network infrastructure, making parameter
 optimization the only viable short-term solution 
\begin_inset CommandInset citation
LatexCommand citep
key "Nawrocki_Understanding:2006"

\end_inset

.
\end_layout

\begin_layout Standard
There are different approaches in the literature that are able to solve
 the coverage problem 
\begin_inset CommandInset citation
LatexCommand citep
key "Nawrocki_Understanding:2006,Siomina_Pilot.power.optimization:2004"

\end_inset

.
 Some of them even claim to achieve near-optimal solutions 
\begin_inset CommandInset citation
LatexCommand citep
key "Siomina:Minimum.pilot.power.for.service.coverage"

\end_inset

.
 As a matter of fact, such formulations have proven useful only for small
 network instances and often fail when challenged with real-world networks.
\end_layout

\begin_layout Standard
The idea of using autonomous agents for optimization is not new.
 It has proven to be a solid optimization approach for solving different
 types of problems, not only within the area of mobile networks 
\begin_inset CommandInset citation
LatexCommand citep
key "Esposito_Genetic.optimization.for.optimum.3G.network.planning:2010,Cheung_Realtime.video.using.agent.over.3G.networks:2005"

\end_inset

, but also in other fields 
\begin_inset CommandInset citation
LatexCommand citep
key "Vasile_Hybrid.multiagent.approach.for.optimization:2009,Valcarce_Applying.FDTD.to.the.coverage.prediction.of.WiMAX:2009"

\end_inset

.
 Nevertheless, we have not observed any similar optimization method for
 solving the service coverage problem in mobile networks 
\begin_inset CommandInset citation
LatexCommand citep
key "Benedicic_Pilot.power.optimization:2010"

\end_inset

.
 Moreover, this is, to the best of our knowledge, the first work to experiment
 with optimization of a real UMTS network on a fully-enabled GPU environment.
\end_layout

\begin_layout Standard
Our optimization approach is based on a state-of-the-art mathematical model,
 that has been previously used to solve a comparable problem 
\begin_inset CommandInset citation
LatexCommand cite
key "Chen-Yuan_CPICH.optimization:2008"

\end_inset

.
 We tackle the problem of computational-time complexity when dealing with
 big problem instances by implementing a parallel version of our agent-based
 algorithm entirely on GPU.
 This minimizes overhead when deploying a larger number of agents working
 in parallel over the service area, limited only by the amount of memory
 available.
 
\end_layout

\begin_layout Standard
We tested our algorithm on subsets of a real UMTS network deployed in Slovenia.
 All network-related data were provided by the mobile operator Mobitel Telecommu
nication Services, Inc.
 The results show that the solutions found, and more importantly their quality,
 are greatly improved when compared to other common planning techniques.
\end_layout

\begin_layout Standard
We begin our discussion by introducing previous work and a description of
 the coverage problem, where we formally introduce some of its key elements.
 We then discuss our parallel-agent approach in detail, as well as the strategie
s used for result comparison.
 Having introduced the parallel-agent approach, we move on to describe the
 GPU implementations of its two key elements: the objective-function evaluator
 and the agents.
 Simulations and experimentation, performed on three sub-networks of a real
 mobile network deployed in Slovenia, follow.
 We conclude with an overview of the achieved results, from the optimization
 as well as the implementation points of view, and discuss future research
 directions.
\end_layout

\begin_layout Section
Previous work
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset citation
LatexCommand citep
key "Siomina:Minimum.pilot.power.for.service.coverage"

\end_inset

, Siomina and Yuan considered the problem of minimizing the total amount
 of pilot power subject to a full coverage constraint.
 They tackled the problem with an iterative linear programming approach,
 reporting very good results for some small-sized test networks.
 The authors also noted that bigger problem instances could not be solved
 because of hardware constraints on the target platform.
\end_layout

\begin_layout Standard
In a different work 
\begin_inset CommandInset citation
LatexCommand citep
key "Benedicic_Pilot.power.optimization:2010"

\end_inset

, we tackled the full-coverage problem of the service area under optimization.
 Reported experimentation on the same problem instances as in 
\begin_inset CommandInset citation
LatexCommand citep
key "Siomina:Minimum.pilot.power.for.service.coverage"

\end_inset

 showed improved quality at the cost of longer running time.
 Moreover, our approach was not limited by any hardware restrictions, since
 it successfully tackled bigger problem instances, finding high quality
 solutions even for large networks.
 Such solutions were found in a reduced amount of time by increasing the
 number of agents deployed during optimization without compromising solution
 quality.
\end_layout

\begin_layout Standard
The algorithm in 
\begin_inset CommandInset citation
LatexCommand citep
key "Benedicic_Pilot.power.optimization:2010"

\end_inset

 is the basis for the optimization algorithm presented in this paper, with
 some essential improvements, namely:
\end_layout

\begin_layout Itemize
the original implementation was completely CPU-based and used a black-box
 coverage evaluator;
\end_layout

\begin_layout Itemize
the algorithm presented here contains improvements in the agent's behavior
 during optimization, including the introduction of the so-called 
\begin_inset Quotes eld
\end_inset

special
\begin_inset Quotes erd
\end_inset

 agents and some fine-tuning of their step sets.
\end_layout

\begin_layout Section
Problem description
\end_layout

\begin_layout Standard
In the problem of optimization of pilot powers for service coverage, the
 objective is to find a set of pilot power settings for all cells in the
 network, such that the total pilot power used is minimized, and a given
 service coverage criteria is fulfilled.
 We consider the pilot power minimization problem subject to a full coverage
 constraint of the service area.
\end_layout

\begin_layout Standard
Because the mathematical model of the problem is not of primary interest
 here, we will just outline it, so that all problem elements are formally
 defined and represented.
 For additional information regarding mathematical models of comparable
 problems, see 
\begin_inset CommandInset citation
LatexCommand citep
key "Nawrocki_Understanding:2006"

\end_inset

.
\end_layout

\begin_layout Subsection
Problem elements
\end_layout

\begin_layout Standard
We start by considering a UMTS network of 
\begin_inset Formula $m$
\end_inset

 cells and use 
\begin_inset Formula $C$
\end_inset

 to denote the set of cells, i.e.
 
\begin_inset Formula $C=\{1,...,m\}$
\end_inset

.
 A pixel grid of a given resolution represents the service area for which
 the signal propagation predictions are known.
 Let 
\begin_inset Formula $n$
\end_inset

 denote the total number of pixels in the service area and let 
\begin_inset Formula $S$
\end_inset

 denote the pixel set, i.e.
 
\begin_inset Formula $S=\{1,...,n\}$
\end_inset

.
 We also denote 
\begin_inset Formula $att_{cs}$
\end_inset

, 
\begin_inset Formula $0\le att_{cs}\le1$
\end_inset

, as the attenuation factor between a cell 
\begin_inset Formula $c$
\end_inset

 and a pixel 
\begin_inset Formula $s$
\end_inset

, which is calculated by performing signal propagation predictions for every
 pair of 
\begin_inset Formula $c\in C$
\end_inset

 and 
\begin_inset Formula $s\in S$
\end_inset

.
\end_layout

\begin_layout Standard
For every 
\begin_inset Formula $c\in C$
\end_inset

, we define 
\begin_inset Formula $p_{c}^{T}$
\end_inset

 as the total transmission power available in cell 
\begin_inset Formula $c$
\end_inset

.
 This power is shared among all channels in the cell (i.e.
 CPICH, other common channels, and dedicated traffic channels).
 We define 
\begin_inset Formula $p_{c}$
\end_inset

 as the amount of power allocated to the pilot signal of cell 
\begin_inset Formula $c$
\end_inset

, where 
\begin_inset Formula $p_{c}$
\end_inset

 may adopt any value from a finite set of possible pilot power levels, 
\begin_inset Formula $P_{c}=\{p_{c}^{1},p_{c}^{2},...,p_{c}^{T}\}$
\end_inset

.
 Consequently, the received pilot power of cell 
\begin_inset Formula $c$
\end_inset

 in pixel 
\begin_inset Formula $s$
\end_inset

 is 
\begin_inset Formula $att_{cs}p_{c}$
\end_inset

.
\end_layout

\begin_layout Standard
Considering the full coverage constraint, each pixel in the service area
 should have at least one cell covering it.
 We assume that a pixel 
\begin_inset Formula $s$
\end_inset

 is under coverage of a cell 
\begin_inset Formula $c$
\end_inset

 if its signal-to-interference ratio, 
\begin_inset Formula $SIR$
\end_inset

, at pixel 
\begin_inset Formula $s$
\end_inset

 is not lower than a given threshold, 
\begin_inset Formula $\gamma_{c}$
\end_inset

, i.e.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
SIR(c,s)=\frac{p_{c}att_{cs}}{\sum_{i\in C}p_{i}^{T}att_{is}+\tau_{0}}\ge\gamma_{c}\label{eq:sir}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $\tau_{0}$
\end_inset

 is the thermal noise.
 In (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:sir"

\end_inset

), we are assuming that all cells in the network operate at full power,
 which is the worst case scenario.
 This ensures that even under heavy user traffic, full coverage of the service
 area is maintained, because of the cell-breathing principle 
\begin_inset CommandInset citation
LatexCommand citep
key "Holma_WCDMA.for.UMTS:2005"

\end_inset

.
 The same assumption has also been used in 
\begin_inset CommandInset citation
LatexCommand citep
key "Siomina:Minimum.pilot.power.for.service.coverage,Chen-Yuan_CPICH.optimization:2008"

\end_inset

.
\end_layout

\begin_layout Standard
The optimization problem corresponds to finding the pilot power levels 
\begin_inset Formula $p_{c}$
\end_inset

, for all cells 
\begin_inset Formula $c\in C$
\end_inset

, such that coverage of at least 
\begin_inset Formula $b$
\end_inset

 pixels is guaranteed, while the total amount of pilot power used is minimized.
 Since we are considering full coverage, we denote 
\begin_inset Formula $b=n$
\end_inset

.
\end_layout

\begin_layout Subsection
Problem complexity 
\begin_inset CommandInset label
LatexCommand label
name "sub:Problem-complexity"

\end_inset


\end_layout

\begin_layout Standard
It has been proved that the problem of pilot power optimization for full
 coverage of the service area is 
\begin_inset Formula $NP$
\end_inset

-hard, since it can be reduced to the set covering problem 
\begin_inset CommandInset citation
LatexCommand citep
key "Varbrand_Mathematical.programming.approach:2003"

\end_inset

.
 Consequently, as long as 
\begin_inset Formula $P\neq NP$
\end_inset

, it is unfeasible that a polynomial-time algorithm exists, which is able
 to find an exact solution to this problem.
\end_layout

\begin_layout Subsection
Optimization objective and constraints
\end_layout

\begin_layout Standard
The optimization objective is defined as follows
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
P^{*}=\min\sum_{c\in C}p_{c};\label{eq:objective_function-1}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
subject to
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\frac{\sum_{s\in S}cov(s)}{b}=1,\label{eq:coverage_constraint}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
where
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
cov(s)=1\,\,\, if\, and\, only\, if\,\,\,\exists c\vert SIR(c,s)\ge\gamma_{c}\label{eq:coverage}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
cov(s)=0\,\,\, otherwise
\]

\end_inset


\end_layout

\begin_layout Standard
The definition of (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:coverage"

\end_inset

) provides us a simple way of asserting the coverage of a given pixel, 
\begin_inset Formula $s$
\end_inset

.
 It follows that if the pilot signal of at least one cell 
\begin_inset Formula $c$
\end_inset

 satisfies the imposed 
\begin_inset Formula $SIR$
\end_inset

 threshold, 
\begin_inset Formula $\gamma_{c}$
\end_inset

, the pixel is covered and hence 
\begin_inset Formula $cov(s)=1$
\end_inset

.
\end_layout

\begin_layout Section
Optimization approaches 
\begin_inset CommandInset label
LatexCommand label
name "sec:Solution-approaches"

\end_inset


\end_layout

\begin_layout Standard
Since the problem instances we will be analyzing are part of a real mobile
 network deployed in Slovenia by Mobitel Telecommunication Services, Inc.,
 there are no references in the literature of other optimization techniques
 dealing with exactly the same data set.
 For this reason, we will introduce two different strategies for setting
 the pilot power, that shall enable us to compare the experimentation results.
 The first strategy is attenuation-based pilot power, presented in 
\begin_inset CommandInset citation
LatexCommand citep
key "Siomina_Pilot.power.optimization:2004"

\end_inset

, in which a pixel of the service area is always covered by the cell with
 the highest attenuation-factor value.
 The second strategy is our parallel-agent approach, based on ideas inspired
 by two-dimensional cellular automata 
\begin_inset CommandInset citation
LatexCommand citep
key "Sarkar_Cellular.automata.history:2000"

\end_inset

 and metaheuristics 
\begin_inset CommandInset citation
LatexCommand citep
key "Talbi_Metaheuristics:2009"

\end_inset

.
 A detailed description is given in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Parallel-multi-agent-approach"

\end_inset

.
\end_layout

\begin_layout Standard
Similar criteria for result comparison have also been used in 
\begin_inset CommandInset citation
LatexCommand citep
key "Siomina:Minimum.pilot.power.for.service.coverage"

\end_inset

.
\end_layout

\begin_layout Subsection
Attenuation-based pilot power
\end_layout

\begin_layout Standard
The first heuristic for setting the pilot power of all cells in the network
 is known as attenuation-based, since it relies on the attenuation factor,
 
\begin_inset Formula $att_{cs}$
\end_inset

.
 A pixel of the service area, 
\begin_inset Formula $s$
\end_inset

, is always covered by the cell exhibiting the maximum 
\begin_inset Formula $att_{cs}$
\end_inset

.
 Whenever the maximum available power, 
\begin_inset Formula $p_{c}^{T}$
\end_inset

, is the same for all the cells in the network, this is equivalent to selecting
 the cell with the minimum required pilot power to cover pixel 
\begin_inset Formula $s$
\end_inset

.
 Hence, under this assumption, we identify the cell 
\begin_inset Formula $c$
\end_inset

 covering pixel 
\begin_inset Formula $s$
\end_inset

 as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
p_{c(s)}=\min_{c\in C}p_{cs}\label{eq:attenuation_based-power}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Picking the cells conforming to (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:attenuation_based-power"

\end_inset

) and setting the pilot powers accordingly, we achieve full coverage of
 the service area with a solution exhibiting a total pilot power of
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
P^{Att}=\sum_{c\in C}\max p_{c(s)}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The procedure to find a cell 
\begin_inset Formula $c(s)$
\end_inset

 for every pixel in the service area consists in sorting, in descending
 order, all pixels by the maximum attenuation factor value, 
\begin_inset Formula $att_{cs}$
\end_inset

, among all cells, i.e.
 
\begin_inset Formula $att_{c(s),s}$
\end_inset

.
 The solution is thus established by the first 
\begin_inset Formula $b$
\end_inset

 pixels of the sorted sequence, taking the maximum pilot power setting for
 a cell into account, i.e.
 
\begin_inset Formula $p_{c(s)}$
\end_inset

.
\end_layout

\begin_layout Subsection
Parallel-agent approach 
\begin_inset CommandInset label
LatexCommand label
name "sub:Parallel-multi-agent-approach"

\end_inset


\end_layout

\begin_layout Standard
In the parallel-agent approach, a set of autonomous worker agents explore
 the geographic area, targeted to be under mobile network coverage, in order
 to optimize the pilot power consumption of the network.
 Each agent randomly moves over the service area as it dictates different
 changes to the pilot power of the cells.
 An objective-function evaluator performs radio propagation predictions
 based on each agent's proposed change.
\end_layout

\begin_layout Standard
The search process during optimization is strictly random.
 However, several physical properties that are exclusive to the problem
 being solved are being exploited during exploration of the search space.
 Additionally, whenever the current solution breaks any of the given constraints
, the optimization process is guided back to the space of valid solutions,
 providing a mechanism for improving exploration and escaping from local
 optima.
\end_layout

\begin_layout Standard
Because of the independent nature in agent's behavior, a parallel implementation
 is fairly straightforward to achieve.
 The first hardware restriction we have to overcome is the amount of memory
 on the GPU device.
 Consequently, careful memory utilization and organization are critical
 to successfully accommodate all involved problem elements on the GPU.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Architecture"

\end_inset

 gives an overview of the optimization system architecture.
 Within this GPU-only architecture, agents work in a parallel and autonomous
 manner, while the evaluator reacts to agents' changes.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/architecture.eps
	lyxscale 30
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
Architecture of the optimization system on GPU.
\begin_inset CommandInset label
LatexCommand label
name "fig:Architecture"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The agents
\end_layout

\begin_layout Standard
The agents apply the pilot power changes based exclusively on local information.
 Each of them encapsulates a set of steps that is consistently applied as
 it randomly moves through the service area of the network.
 Whenever an agent arrives at a pixel 
\begin_inset Formula $s$
\end_inset

, it identifies the set of cells covering the current pixel, namely 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
B(s)=\{c\in C\mid SIR(c,s)\ge\gamma_{c}\}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
Pseudo-code of the agent's behavior.
\begin_inset CommandInset label
LatexCommand label
name "tab:Agent-behavior"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="14" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomspace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Step
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathbf{repeat}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\,\,\,\,\mathbf{if}\, Special\, agent\,(\,)\,\mathbf{and}\,|U|>0\,\mathbf{then}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\,\,\,\,\,\,\,\, s=random\, element\, from\, U$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\,\,\,\,\mathbf{else}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\,\,\,\,\,\,\,\, s=random\, element\, from\, S$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\,\,\,\,\mathbf{end\, if}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\,\,\,\, move\, to\, s$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\,\,\,\,\mathbf{if}\,|B(s)|=0\,\mathbf{then}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\,\,\,\,\,\,\,\, apply\, SS_{0}\,\,\,\,//increase\, power$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\,\,\,\,\mathbf{else\,}\mathbf{if}\,|B(s)|\ge1\,\mathbf{then}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\,\,\,\,\,\,\,\, apply\, SS_{1}\,\,\,\,//decrease\, power$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\,\,\,\,\mathbf{end\, if}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathbf{while\,}\mathbf{not}\,(stopping\, criteria)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The step set applied from this point on directly depends on the cardinality
 of 
\begin_inset Formula $B(s)$
\end_inset

, while the agent's movement over the service area is determined by the
 cardinality of set 
\begin_inset Formula $U$
\end_inset

, 
\begin_inset Formula $U\subset S$
\end_inset

, which is defined as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
U=\{s\in S\mid\forall c\in C:SIR(c,s)<\gamma_{c}\}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The agent's behavior is dictated by the pseudo-code shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Agent-behavior"

\end_inset

.
 Steps 1 to 4 are responsible for guiding the agent's movement.
 The coordinates are selected randomly from two sets.
 The first, 
\begin_inset Formula $S$
\end_inset

, is the set of all pixels in the service area.
 The other one, 
\begin_inset Formula $U$
\end_inset

, is the set of pixels that are currently not being covered by the network.
 Only 
\begin_inset Quotes eld
\end_inset

special
\begin_inset Quotes erd
\end_inset

 agents may select pixel coordinates of the set 
\begin_inset Formula $U$
\end_inset

.
 It follows, that an agent's movement depends on its 
\begin_inset Quotes eld
\end_inset

specialty
\begin_inset Quotes erd
\end_inset

 and the number of pixels not covered by the current solution.
 During steps 5 to 8, the agent applies step sets 
\begin_inset Formula $SS_{0}$
\end_inset

 and 
\begin_inset Formula $SS_{1}$
\end_inset

 based on the number of cells in 
\begin_inset Formula $B(s)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
Pseudo-code of step set 
\begin_inset Formula $SS_{0}$
\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "tab:Rule-set-0"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomspace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Step
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathbf{repeat}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\,\,\,\, c'=next\, cell\, with\, maximum\, att(s)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\,\,\,\, p_{c'}=Adjust\, pilot(c',increase\, rate)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathbf{while}\,(p_{c'}\notin P_{c'})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the agent's current location, at pixel 
\begin_inset Formula $s$
\end_inset

, is not covered by any cell (i.e.
 
\begin_inset Formula $|B(s)|=0$
\end_inset

), the step set 
\begin_inset Formula $SS_{0}$
\end_inset

 (shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Rule-set-0"

\end_inset

) is applied.
 It starts by selecting the cell with the maximum attenuation factor at
 pixel 
\begin_inset Formula $s$
\end_inset

 (step 1).
 If many cells have the same value, one is randomly picked out of them.
 Once 
\begin_inset Formula $c'$
\end_inset

 is uniquely identified, the agent changes its pilot power by 
\begin_inset Formula $increase\, rate$
\end_inset

 dB (step 2).
 By using a higher 
\begin_inset Formula $increase\, rate$
\end_inset

, the network shall potentially cover 
\begin_inset Formula $s$
\end_inset

, as well as some neighboring pixels.
 Areas without coverage usually contain many uncovered pixels grouped together,
 forming irregular uncovered islands.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
Pseudo-code of step set 
\begin_inset Formula $SS_{1}$
\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "tab:Rule-set-1"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomspace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Step
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathbf{repeat}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\,\,\,\, c'=next\, random\, cell(B(s))$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\,\,\,\, p_{c'}=Adjust\, pilot(c',decrease\, rate)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathbf{while}\,(p_{c'}\notin P_{c'})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The step set 
\begin_inset Formula $SS_{1}$
\end_inset

 in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Rule-set-1"

\end_inset

 is applied whenever the agent's current location, at pixel 
\begin_inset Formula $s$
\end_inset

, is covered by one or more cells (i.e.
 
\begin_inset Formula $|B(s)|\ge1$
\end_inset

).
 The first step randomly selects a cell from 
\begin_inset Formula $B(s)$
\end_inset

.
 The agent shall decrease the pilot power of 
\begin_inset Formula $c'$
\end_inset

 in step 2.
 This practice keeps the coverage constraint valid over 
\begin_inset Formula $s$
\end_inset

, although it might potentially break it on other pixels.
 Ideally, every pixel would be covered by exactly one network cell, although
 this is just a representation of a perfect solution that is almost entirely
 unreachable, because of the irregularity in network topology and terrain.
\end_layout

\begin_layout Standard
In both step sets, 
\begin_inset Formula $SS_{0}$
\end_inset

 and 
\begin_inset Formula $SS_{1}$
\end_inset

, the agent makes sure that the new pilot power setting, i.e.
 after applying the change, is an element of 
\begin_inset Formula $P_{c'}$
\end_inset

.
 If this is not the case, cell 
\begin_inset Formula $c'$
\end_inset

 is discarded and another cell is selected at the first step of 
\begin_inset Formula $SS_{0}$
\end_inset

 and 
\begin_inset Formula $SS_{1}$
\end_inset

, adjusting its pilot power accordingly.
 
\end_layout

\begin_layout Standard
The values 
\begin_inset Formula $increase\, rate$
\end_inset

 and 
\begin_inset Formula $decrease\, rate$
\end_inset

 are configurable parameters that should be set before starting the optimization
 process.
 They indicate the dB adjustment proposed to the pilot power of cell 
\begin_inset Formula $c'$
\end_inset

 and are based on the physical properties of the problem being solved.
 Namely, lowering the pilot power of a cell decreases the interference at
 pixel 
\begin_inset Formula $s$
\end_inset

.
 Moreover, the target 
\begin_inset Formula $SIR$
\end_inset

 value at pixel 
\begin_inset Formula $s$
\end_inset

 is reduced under lower interference; thus coverage of this pixel may be
 achieved with lower pilot power.
 On the other hand, by increasing the pilot power of a cell with the maximum
 
\begin_inset Formula $att_{s}$
\end_inset

, we improve coverage by evenly distributing the power among different network
 cells, since the selected cell, 
\begin_inset Formula $c'$
\end_inset

, is, on average, the nearest to the present location.
\end_layout

\begin_layout Subsubsection
The evaluator
\end_layout

\begin_layout Standard
The evaluator represents a central component of the optimization system,
 since it reacts to agents' changes by recalculating the value of the objective
 function, i.e.
 coverage of the service area and the total pilot power used by all the
 cells in the network being optimized.
\end_layout

\begin_layout Standard
After a short initialization, during which the path-loss matrices for all
 the cells and the interference matrix for the whole area are calculated,
 the evaluator computes the service area coverage, based on the pilot powers
 supplied as the initial solution from which the search process begins.
 Initial solutions are randomly generated sets, containing valid pilot power
 settings that fulfill the coverage constraint.
 The evaluator then waits for agents' changes to arrive and calculate subsequent
 objective function values accordingly.
\end_layout

\begin_layout Standard
It is responsibility of the evaluator to maintain a special part of memory,
 intended for keeping track of the uncovered pixels in the service area,
 constantly updated.
 Whenever the current solution is not valid because of uncovered pixels,
 i.e.
 (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:coverage_constraint"

\end_inset

) does not hold, some 
\begin_inset Quotes eld
\end_inset

special
\begin_inset Quotes erd
\end_inset

 agents randomly select an uncovered pixel coordinate from this portion
 of memory so that a valid solution may be reached again.
 It should be noted that these 
\begin_inset Quotes eld
\end_inset

special
\begin_inset Quotes erd
\end_inset

 agents shall only apply step set 
\begin_inset Formula $SS_{0}$
\end_inset

 for as long as the solution is not valid.
 The portion of 
\begin_inset Quotes eld
\end_inset

special
\begin_inset Quotes erd
\end_inset

 agents that may work in correcting the current solution is an optimization
 parameter.
\end_layout

\begin_layout Standard
As it has been mentioned before, this constraint-repairing strategy enhances
 certain properties of the search process performed, namely:
\end_layout

\begin_layout Itemize
increased exploration of the search space, as different regions are also
 being inspected, and
\end_layout

\begin_layout Itemize
to enable the algorithm to escape from local optima, leading the search
 to other areas containing potentially good solutions.
\end_layout

\begin_layout Standard
It is worth mentioning that the evaluator itself has no influence in the
 optimization process from a theoretical point-of-view.
 Its task is to provide feedback and updated information to the agents exploring
 the service area.
 From a performance point-of-view, the importance of the evaluator is significan
t, as it will be shown in the next sections.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
We have chosen the Open Computing Language (OpenCL) 
\begin_inset CommandInset citation
LatexCommand citep
key "Stone_OpenCL.A.parallel.programming.standard:2010"

\end_inset

 as the implementation platform of our optimization system on GPU.
\end_layout

\begin_layout Standard
OpenCL is an open parallel computing API designed to enable GPUs and other
 co-processors to work together with the CPU, providing additional computing
 power.
 As a standard, OpenCL 1.0 was released in 2008, by The Khronos Group, an
 independent standards consortium 
\begin_inset CommandInset citation
LatexCommand citep
key "Munshi_The.OpenCL.specification:2009"

\end_inset

.
 For additional information about the OpenCL standard and API, we refer
 the reader to the numerous guides available online.
\end_layout

\begin_layout Standard
Our choice in using OpenCL was greatly influenced by the fact that its bitcode
 runs on a variety of hardware, including multicore CPUs and GPUs from different
 vendors.
 This provides a complete framework capable of comparing execution speed-up
 on different hardware without the need of changing the implementation.
 
\end_layout

\begin_layout Standard
One unfortunate consequence of the vendor variety is that NVIDIA's CUDA
 
\begin_inset CommandInset citation
LatexCommand citep
key "NVIDIA_Compute.Unified.Device.Architecture:2007"

\end_inset

 and OpenCL documentation present disparate naming conventions for some
 key components.
 For the sake of consistency, in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:CUDA-OpenCL-translation"

\end_inset

, we present a short 
\begin_inset Quotes eld
\end_inset

translation dictionary
\begin_inset Quotes erd
\end_inset

 between them.
 In the remaining of this work, we will stick to the naming convention used
 in the CUDA documentation.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
Terminology translation between OpenCL and CUDA 
\begin_inset CommandInset citation
LatexCommand citep
key "Kloeckner_CUDA.OpenCL.dictionary:2011"

\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "tab:CUDA-OpenCL-translation"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="2">
<features tabularvalignment="middle">
<column alignment="right" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomspace="default">
<cell alignment="right" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
OpenCL
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
CUDA
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Grid
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Grid
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Work group
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Block
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Work item
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Thread
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__kernel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__global__
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__global
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__device__
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__local
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__shared__
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__private
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__local__
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
image
\emph on
n
\emph default
d_t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
texture<type,
\emph on
n
\emph default
,...>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
barrier(L|M|F)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__syncthreads( )
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
get_local_id(0|1|2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
threadIdx.x|y|z
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
get_group_id(0|1|2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
blockIdx.x|y|z
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
get_global_id(0|1|2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
(not implemented)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Despite the use of OpenCL as the target platform for our implementation,
 the details described in the next sections may be equally applied on CUDA.
\end_layout

\begin_layout Standard
The evaluator was completely implemented on the GPU, because its performance
 has a great impact on the speed of the optimization system as a whole.
 Agents' implementation is also based on the GPU, which drastically reduces
 the number of data transfers between CPU and GPU, since all problem elements
 are available on the GPU during the optimization process.
 Therefore, it is a challenging task to accommodate all the needed elements
 on GPU memory, which is notably smaller than the RAM memory usually available
 on modern desktop computers.
\end_layout

\begin_layout Subsection
Objective function evaluation on GPU 
\begin_inset CommandInset label
LatexCommand label
name "sub:Objective-function-evaluation"

\end_inset


\end_layout

\begin_layout Standard
As it was mentioned before, the crucial importance of the evaluator as an
 element of the optimization system made it the first component to be implemente
d on the GPU and, thus, have a greater gain on the performance speed-up
 of the system.
\end_layout

\begin_layout Standard
The GPU implementation of the objective function evaluator is based on work
 done by Hrovat et al.
 
\begin_inset CommandInset citation
LatexCommand citep
key "Ozimek_Open.source.radio.coverage.prediction:2010"

\end_inset

.
 The evaluator implementation is one of the biggest challenges we faced.
 The great amount of data needed to evaluate agents' changes of pilot power
 was the first restriction we run into, as there was not enough memory on
 the GPU for all of them.
 The solution is to change their internal representation, namely:
\end_layout

\begin_layout Itemize
one path-loss matrix for each of the cells of the network being optimized,
\end_layout

\begin_layout Itemize
one interference matrix for the whole service area.
\end_layout

\begin_layout Standard
The path-loss matrices are potentially as big as the underlying data used
 to calculate the radio propagation predictions over the service area of
 the network.
 In our case, we are dealing with an area of more than 78000 
\begin_inset Formula $km^{2}$
\end_inset

, including a digital elevation model of 100 
\begin_inset Formula $m^{2}$
\end_inset

 resolution.
 This grid includes the whole country and some of the neighboring ones,
 ensuring data availability even at the country borders.
 Having more than 100 transmitters containing real numbers as matrix elements,
 requires more memory than is currently available on most modern GPU hardware.
 For this reason, we decided to change the path-loss matrix elements unit
 from the linear scale to decibels (dB), coding them as 
\emph on
unsigned char
\emph default
.
 After consultation with experts on the radio-telecommunications field,
 the decision was that the additional error introduced by using integer
 decibels instead of real numbers is negligible, since the digital elevation
 model, which has a resolution of 100 
\begin_inset Formula $m2$
\end_inset

 per pixel, presents a bigger rounding problem.
 The path-loss between a network cell and any point on the service area
 should, consequently, never exceed -255 dB.
 This scale is large enough for problem representation, since service discovery
 by the mobile terminal is still successful with a RSCP of around -115 dB
 
\begin_inset CommandInset citation
LatexCommand citep
key "Holma_WCDMA.for.UMTS:2005"

\end_inset

.
 We also include a calculation radius around each network cell to reduce
 the amount of memory needed even more.
 For example, take a 60 
\begin_inset Formula $km$
\end_inset

 calculation radius around each cell, which is enough for the coverage calculati
on purposes over the 2 GHz spectrum of UMTS 
\begin_inset CommandInset citation
LatexCommand citep
key "Holma_WCDMA.for.UMTS:2005"

\end_inset

, yet it drastically lowers the memory requirement on the GPU.
 To correctly locate the path-loss matrices within the service area, we
 supply the offset of the upper-left corner of each of them.
 The memory layout for the path-loss matrices is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:path-loss_matrices_memory_organization"

\end_inset

.
 Because their content is constant throughout the optimization process,
 they are kept in read-only texture memory to take advantage of the fast
 access time.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/pathloss_matrices.eps
	lyxscale 30
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
Memory organization of the path-loss matrices for network cells.
\begin_inset CommandInset label
LatexCommand label
name "fig:path-loss_matrices_memory_organization"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Additional speed-up is achieved by incrementally recalculating the service
 area coverage as the agents' changes arrive.
 Specifically, the network cells containing new settings that have not yet
 been evaluated, have their pilot powers saved in negative form, serving
 as a flag to indicate that coverage re-evaluation is needed.
 Since pilot powers are, by definition, positive numbers, there is no possibilit
y for confusion.
\end_layout

\begin_layout Subsection
Parallel agents on GPU
\end_layout

\begin_layout Standard
The autonomous and programmable nature of the agents make them ideal for
 parallel and GPU-based implementations.
 By lowering the complexity of the step sets applied at each time, we were
 able to tackle a large optimization problem with outstanding results in
 very short time.
\end_layout

\begin_layout Standard
For the agents' kernel, only one thread block is launched.
 It contains as many threads as there are agents deployed during the optimizatio
n, organized in a 1D grid.
 Each thread randomly generates a coordinate within the service area, using
 the system time in milliseconds as a random seed.
 Because OpenCL lacks functions for random-number generation, we implemented
 a simplified version of Marsaglia's generator 
\begin_inset CommandInset citation
LatexCommand citep
key "Marsaglia_Seeds.for.random.number.generator:2003"

\end_inset

.
 Afterwards, each thread analyzes the received signals at the current coordinate
 by applying step sets 
\shape italic

\begin_inset Formula $SS_{0}$
\end_inset


\shape default
 or 
\shape italic

\begin_inset Formula $SS_{1}$
\end_inset


\shape default
, as it has been explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Parallel-multi-agent-approach"

\end_inset

.
 Each thread saves in shared memory the outcome of its analysis, containing
 the 
\emph on
id
\emph default
 of the network cell (at position 
\begin_inset Formula $2\times threadIdx$
\end_inset

), and the pilot power setting (at position 
\begin_inset Formula $2\times threadIdx+1$
\end_inset

).
 The new pilot power is calculated as the dB difference from the previous
 one, based on the values of 
\begin_inset Formula $increase\, rate$
\end_inset

 and 
\begin_inset Formula $decrease\, rate$
\end_inset

.
 Since both numbers, i.e.
 the cell 
\emph on
id
\emph default
 and the pilot power, are of type 
\emph on
unsigned short
\emph default
, there is enough room in a 16 Kb shared memory block to allocate up to
 4,096 independent agents.
 Therefore, this number is not bounded by shared-memory size, since most
 GPUs have a limit in the number of threads per block of 256, 512, etc.
 The last step involves saving the new pilot powers back to their containing
 vector in global memory.
 This is done by only one of the threads within the block, to avoid memory-acces
s conflicts.
 At this moment, the sign of updated pilot powers is changed to indicate
 that coverage re-calculation is needed.
 Clearly, the vector containing pilot powers in global memory is of type
 
\emph on
int
\emph default
, as it must allow signed values.
 Nevertheless, a single pilot power setting never exceeds 65,535 in milliwatt
 units.
 In case there is more than a new setting for a specific network cell, the
 median is calculated and applied as the new pilot power for that cell.
\end_layout

\begin_layout Standard
Even though coalesced access is not achieved by the agents' kernel, its
 sole implementation provided enhanced performance, since the compulsory
 data transfers between the CPU and the GPU at each time step during optimizatio
n are minimized.
 It also produces truly parallel behavior of the agents, as they apply pilot
 power changes at the same time.
\end_layout

\begin_layout Section
Simulations
\end_layout

\begin_layout Subsection
Test networks
\end_layout

\begin_layout Standard
All the test networks, 
\begin_inset Formula $Net_{1}$
\end_inset

, 
\begin_inset Formula $Net_{2}$
\end_inset

 and 
\begin_inset Formula $Net_{3}$
\end_inset

 are subsets of a real UMTS network deployed by Mobitel Telecommunication
 Services, Inc.
 in Slovenia.
 The path-loss predictions are calculated using the COST231 model 
\begin_inset CommandInset citation
LatexCommand citep
key "Cichon_Propagation.prediction.models:1995"

\end_inset

, using a digital evaluation model of 100 
\begin_inset Formula $m^{2}$
\end_inset

 resolution as input data and a receiver height of 
\begin_inset Formula $1.5\, m$
\end_inset

 above ground.
 The requirements for 
\begin_inset Formula $SIR$
\end_inset

 coverage were provided by experts of the Radio Network Department at Mobitel
 Telecommunication Services, Inc.
\end_layout

\begin_layout Standard
\begin_inset Formula $Net_{1}$
\end_inset

 is deployed over a densely populated urban area.
 For this reason, the 
\begin_inset Formula $SIR$
\end_inset

 coverage threshold is a lower, since network capacity is the dominating
 factor, whereas coverage is flexible because of a higher cell density,
 i.e.
 more base stations per surface unit.
 
\begin_inset Formula $Net_{2}$
\end_inset

 represents a network deployed over a dominant rural area, meaning that
 network capacity may be reduced at the cost of better coverage, since each
 cell must cover a greater area.
 The last network, 
\begin_inset Formula $Net_{3}$
\end_inset

, represents a suburban area with a highly-dense populated, but relatively
 small, downtown center, where a compromise between network capacity and
 coverage has to be achieved.
\end_layout

\begin_layout Standard
Based on the data available, we have produced network configurations based
 on the attenuation-based approach.
 These configurations represent what could be an initial network setup by
 common planning standards 
\begin_inset CommandInset citation
LatexCommand citep
key "Holma_WCDMA.for.UMTS:2005"

\end_inset

.
 Moreover, such configurations are also very straightforward to calculate
 by a network planner.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:network-statistics"

\end_inset

 shows some statistics of the test networks used.
 The parameter values used during experimentation are shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:network-parameters"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
Network statistics.
\begin_inset CommandInset label
LatexCommand label
name "tab:network-statistics"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features booktabs="true" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row bottomspace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cells 
\begin_inset Formula $[m]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Area 
\begin_inset Formula $[km^{2}]$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Net_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
77
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Net_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
23
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
306.25
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Net_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
129
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
405
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
Network parameters.
\begin_inset CommandInset label
LatexCommand label
name "tab:network-parameters"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Parameter
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Net_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Net_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Net_{3}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p_{c}^{T}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15.00 W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19.95 W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15.00 W
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\tau_{0}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.55
\begin_inset Formula $\cdot10^{-14}$
\end_inset

 W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.55
\begin_inset Formula $\cdot10^{-14}$
\end_inset

 W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.55
\begin_inset Formula $\cdot10^{-14}$
\end_inset

 W
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\gamma_{c}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.01
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.02
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.015
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Algorithm parameter settings 
\begin_inset CommandInset label
LatexCommand label
name "sub:Algorithm-parameter-settings"

\end_inset


\end_layout

\begin_layout Standard
After short experimentation, we determined the parameter settings for the
 optimization algorithm.
 There was no fine tuning of parameters for each problem instance.
 Nevertheless, we gained valuable information regarding the agent's behavior
 that we used to set the following parameter values:
\end_layout

\begin_layout Itemize
\begin_inset Formula $increase\, rate$
\end_inset

 was set to 0.2 dB;
\end_layout

\begin_layout Itemize
\begin_inset Formula $decrease\, rate$
\end_inset

 was set to -0.1 dB;
\end_layout

\begin_layout Itemize
\begin_inset Formula $number\, of\, agents$
\end_inset

 was set to 16; and
\end_layout

\begin_layout Itemize
10,000 
\begin_inset Formula $changes\, per\, agent$
\end_inset

 were allowed.
\end_layout

\begin_layout Subsection
Experimental environment
\end_layout

\begin_layout Standard
All experiments were done on a 4-core, hyper-threading, Intel i7 2.67 GHz
 desktop computer with 6 GB of RAM running a 64-bit Linux operating system.
 The GPU hardware was ATI HD5570, with 1 GB DDR3 RAM.
 The implementation language used was C, with OpenCL and OpenMPI extensions.
\end_layout

\begin_layout Subsection
Optimization results
\end_layout

\begin_layout Standard
The results achieved by our optimization approach improved the objective
 significantly, as it is shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:optimization-results-1"

\end_inset

.
 Results show that we reduced pilot power usage in all networks and kept
 the service area under full coverage.
 Moreover, we may see the solution for 
\begin_inset Formula $Net_{1}$
\end_inset

 improved the attenuation-based setting by more than 300%.
 For 
\begin_inset Formula $Net_{2}$
\end_inset

, the improvement observed is around 232%, with an improvement of more than
 170% for 
\begin_inset Formula $Net_{3}$
\end_inset

.
 These means that network capacity has been significantly increased in all
 three problem instances.
 Therefore, a greater number of users should be able to access services
 provided by the mobile network, since coverage is assured.
 Moreover, an increased speed in data services should be observed 
\begin_inset CommandInset citation
LatexCommand citep
key "Holma_WCDMA.for.UMTS:2005"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
Optimization results.
\begin_inset CommandInset label
LatexCommand label
name "tab:optimization-results-1"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="6">
<features booktabs="true" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row bottomspace="default">
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Attenuation-based
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Parallel agents
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row bottomspace="default">
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total power [W]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Average cell power [W]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total power [W]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Average cell power [W]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Net_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
419.292
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.445
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
137.064
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.780
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Net_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
78.297
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.404
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
33.344
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.450
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Net_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,014.113
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7.861
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
582.954
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.519
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
After collecting data from ten independent runs, we generated convergence
 graphs, shown in Figures 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:convergence_net1"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:convergence_net2"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:convergence_net3"

\end_inset

.
 The graphs contain feasible solutions only, i.e.
 solutions that meet the full-coverage constraint.
 Unfeasible solutions were marked with a value of inferior quality than
 the worst solution found by the algorithm in all ten runs.
 In case of 
\begin_inset Formula $Net_{1}$
\end_inset

, the value was set to 428, for 
\begin_inset Formula $Net_{2}$
\end_inset

 the value was set to 129 and for 
\begin_inset Formula $Net_{3}$
\end_inset

 the value was set to 1,435.
 
\end_layout

\begin_layout Standard
The analysis of convergence graphs of 
\begin_inset Formula $Net_{1}$
\end_inset

 and 
\begin_inset Formula $Net_{2}$
\end_inset

 shows that the algorithm quickly converges at the beginning, followed by
 a steady improvement of intermediate solutions.
 In 
\begin_inset Formula $Net_{1}$
\end_inset

 we notice additional improvement of the solutions found even at towards
 the end.
 This fact suggests that longer runs would potentially find even better
 solutions in this case.
 For the instance 
\begin_inset Formula $Net_{3}$
\end_inset

, we observe a slower initial convergence, with steady improvement of intermedia
te solutions and no significant solution enhancement towards the end.
 This fact, together with the aforementioned results, suggest that this
 problem instance presents a more difficult optimization case than 
\begin_inset Formula $Net_{1}$
\end_inset

 and 
\begin_inset Formula $Net_{2}$
\end_inset

.
 Further investigation would be needed to determine the source of this behavior.
 Nevertheless, the improvement observed is, in average, around 100%.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/convergence_1.eps
	lyxscale 30
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
Convergence results for network 
\begin_inset Formula $Net_{1}$
\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "fig:convergence_net1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/convergence_2.eps
	lyxscale 30
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
Convergence results for network 
\begin_inset Formula $Net_{2}$
\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "fig:convergence_net2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/convergence_3.eps
	lyxscale 30
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
Convergence results for network 
\begin_inset Formula $Net_{3}$
\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "fig:convergence_net3"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Implementation results
\end_layout

\begin_layout Standard
After measuring the quality of the solutions given by our parallel-agent
 approach, we present the experimental results regarding efficiency of different
 implementations.
 For this purpose only execution times and speed-up factors are presented.
 The running time was measured for ten independent runs on each platform.
 The resulting average times are given.
 The number of changes per agent was limited to 100, while all other algorithm
 parameters were kept at the same values as previously stated in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Algorithm-parameter-settings"

\end_inset

.
\end_layout

\begin_layout Standard
The results, shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:speedup-results"

\end_inset

, are reported for different sizes of problem instances, i.e.
 
\begin_inset Formula $Net_{1}$
\end_inset

, 
\begin_inset Formula $Net_{2}$
\end_inset

 and 
\begin_inset Formula $Net_{3}$
\end_inset

.
 These networks provide different combinations of network cells and service
 area size.
 Results are presented for a CPU-only implementation, including objective-functi
on evaluation on CPU and MPI-based agents, GPU objective-function evaluation
 and MPI-based agents, and GPU objective-function evaluation including agents
 on the same GPU.
 The implementation combining CPU-based evaluator and MPI-based agents is
 the basis for the speed-up calculation on the other platforms.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
Implementation-efficiency measures.
\begin_inset CommandInset label
LatexCommand label
name "tab:speedup-results"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="8">
<features booktabs="true" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row bottomspace="default">
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CPU evaluator + MPI agents
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPU evaluator + MPI agents
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPU evaluator + GPU agents
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row bottomspace="default">
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Avg.
 time [sec]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Avg.
 time [sec]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Speed-up
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Avg.
 time [sec]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Speed-up
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Net_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
105,455
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
346
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
305x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
67
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1574x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Net_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
33,700
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
195
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
173x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
46
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
733x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Net_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
191,900
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
506
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
379x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
117
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
927x
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It should be noted that the MPI implementation of the agents, used for the
 first and second measured setups, is not fully parallel, since internal
 synchronizations at network level are performed, so agents' changes arrive
 in a serial fashion to the evaluator, before being analyzed.
 
\end_layout

\begin_layout Standard
Function evaluation on the GPU communicating with agents over MPI provides
 the second measured setup.
 The evaluator implementation takes advantage of shared memory for thread
 collaboration within a block and texture memory for constant elements,
 as is has been explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Objective-function-evaluation"

\end_inset

.
 Still, the speed-up is considerable but improvable, since numerous data
 transfers between CPU and GPU are needed for the agents to access optimization-
related information.
\end_layout

\begin_layout Standard
The last result set presents measurements for complete GPU implementation,
 including objective-function evaluation and agents on the same device.
 The substantial speed-up delivered by this combination highlights the great
 impact that CPU-to-GPU memory transfers have on overall system performance.
 This fact is supported by the speed-up between the second and third measured
 setups, which exhibit, on average, an improvement of more than 400%.
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
In this paper, we have addressed the problem of providing full coverage
 to a service area of a UMTS network by using a minimum amount of pilot
 power.
 We have put emphasis on the confluence of a real-world problem, with live
 data from a deployed mobile network, with state-of-the-art parallel GPU
 hardware and implementations that, to the best of our knowledge, has never
 been dealt-with before.
\end_layout

\begin_layout Standard
We have presented a parallel-agent approach, which is aimed at giving good
 solutions to big problem instances in an acceptable amount of time.
 The experimental results show that our approach is able to find competitive
 solutions, when compared to other common radio-planning methods 
\begin_inset CommandInset citation
LatexCommand citep
key "Holma_WCDMA.for.UMTS:2005"

\end_inset

.
 The presented results also demonstrate that our algorithm is able to find
 high quality solutions even for large networks, that contain many cells
 over a large service area.
 This fact indicates that our approach could be successfully applied to
 bigger problem instances.
\end_layout

\begin_layout Standard
GPU architectures not only allow implementation of parallel heuristics in
 a natural way, they also substantially improve the performance of the optimizat
ion process.
 We reported and validated the great performance gain by experimentation
 on problem instances of different sizes.
\end_layout

\begin_layout Standard
After successfully implementing the objective-function evaluation on GPU,
 we realized that the efficiency of this approach was limited by the CPU-to-GPU
 data transfers.
 Nevertheless, even with such implementation, we have already obtained substanti
al speed-up.
\end_layout

\begin_layout Standard
To deal with the CPU-to-GPU data transfer issue, we implemented a fully-enabled
 GPU optimization system that achieved impressive speed-up.
 Still, we had to consider different data representation schemes for the
 problem elements, so to avoid memory limitations on the GPU device.
 Comparison of our experimental results with other algorithms dealing with
 the same and similar problems would be useful.
 However, this task is not straightforward, since the results of several
 works (e.g.
 
\begin_inset CommandInset citation
LatexCommand citep
key "Gerdenitsch_PhD:2004,Turke_Advanced.site.configuration.techniques:2005"

\end_inset

) depend on black-box evaluations, making experimental association very
 difficult, if possible at all.
 
\end_layout

\begin_layout Standard
All in all, we consider that the present work provides a robust foundation
 for future work on grid-based metaheuristics with expensive objective-function
 evaluation.
\end_layout

\begin_layout Standard
In future work, we will consider further analysis of our parallel-agent
 approach, including experimentation with different parameters, in order
 to gain better understanding of the dynamics leading the metaheuristic
 during the search process.
 Multi-GPU environments present an interesting possibility, where evaluator(s)
 and worker agents are run on separate GPU devices.
\end_layout

\end_body
\end_document
